{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentaci\u00f3n de los tokens de Tikebit. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum tincidunt lorem justo, nec ornare dolor tincidunt id. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Proin sed orci et sapien consequat dignissim quis nec risus. Sed vel quam vitae erat maximus imperdiet a sed purus. Donec quis vulputate libero, a pellentesque velit. Suspendisse at purus vitae risus dapibus consequat nec nec arcu. Curabitur tristique, erat vitae ultrices hendrerit, justo ligula luctus augue, at dictum quam mauris a ligula. Ut risus lectus, tincidunt eget metus id, rutrum rutrum lacus. Suspendisse suscipit, justo ac eleifend vulputate, lacus quam sodales nulla, non tempor odio enim quis libero. Suspendisse sagittis tortor vitae dui posuere lobortis. Etiam bibendum eros vel nulla aliquet, et pellentesque quam porttitor. Quisque quis posuere felis. Pellentesque et ante cursus, semper ex eget, consequat odio. Nullam sit amet nunc lorem. Etiam aliquam molestie consequat.","title":"Documentaci\u00f3n de los tokens de Tikebit."},{"location":"#documentacion-de-los-tokens-de-tikebit","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum tincidunt lorem justo, nec ornare dolor tincidunt id. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Proin sed orci et sapien consequat dignissim quis nec risus. Sed vel quam vitae erat maximus imperdiet a sed purus. Donec quis vulputate libero, a pellentesque velit. Suspendisse at purus vitae risus dapibus consequat nec nec arcu. Curabitur tristique, erat vitae ultrices hendrerit, justo ligula luctus augue, at dictum quam mauris a ligula. Ut risus lectus, tincidunt eget metus id, rutrum rutrum lacus. Suspendisse suscipit, justo ac eleifend vulputate, lacus quam sodales nulla, non tempor odio enim quis libero. Suspendisse sagittis tortor vitae dui posuere lobortis. Etiam bibendum eros vel nulla aliquet, et pellentesque quam porttitor. Quisque quis posuere felis. Pellentesque et ante cursus, semper ex eget, consequat odio. Nullam sit amet nunc lorem. Etiam aliquam molestie consequat.","title":"Documentaci\u00f3n de los tokens de Tikebit."},{"location":"interface/","text":"Todos los c\u00f3digos utilizados provienen del repositorio de Open Zeppelin . ERC20Basic Interfaz para la creaci\u00f3n de tokens ERC20 con las funcionalidades b\u00e1sicas. contract ERC20Basic { function totalSupply() public view returns(uint256); function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); event Transfer(address indexed from, address indexed to, uint256 value); } ERC20 Interfaz complementaria de ERC20Basic que implementa funcionalidades extra para los tokens ERC20. contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns(uint256); function transferFrom(address from, address to, uint256 value) public returns(bool); function approve(address spender, uint256 value) public returns(bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } SafeMath Librer\u00eda utilizada para la implementaci\u00f3n de elementos de seguridad para las operaci\u00f3nes matem\u00e1ticas. Previene los overflows y lo undeflows. library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b = a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256 c) { c = a + b; assert(c = a); return c; } }","title":"Interfaces y librer\u00edas"},{"location":"interface/#erc20basic","text":"Interfaz para la creaci\u00f3n de tokens ERC20 con las funcionalidades b\u00e1sicas. contract ERC20Basic { function totalSupply() public view returns(uint256); function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); event Transfer(address indexed from, address indexed to, uint256 value); }","title":"ERC20Basic"},{"location":"interface/#erc20","text":"Interfaz complementaria de ERC20Basic que implementa funcionalidades extra para los tokens ERC20. contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns(uint256); function transferFrom(address from, address to, uint256 value) public returns(bool); function approve(address spender, uint256 value) public returns(bool); event Approval( address indexed owner, address indexed spender, uint256 value ); }","title":"ERC20"},{"location":"interface/#safemath","text":"Librer\u00eda utilizada para la implementaci\u00f3n de elementos de seguridad para las operaci\u00f3nes matem\u00e1ticas. Previene los overflows y lo undeflows. library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b = a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256 c) { c = a + b; assert(c = a); return c; } }","title":"SafeMath"},{"location":"ownable/","text":"En este caso, es el c\u00f3digo original de Open Zeppelin con varias funciones enfocadas a crear un super usuario que lo \u00fanico que puede hacer es retirar los permisos a la cuenta de owner . Variables owner address public superUser address public Eventos event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); event SuperUserTransferred( address indexed previousSu, address indexed newSu ); Modificadores onlyOwner() Solo la direcci\u00f3n que tenga el rol de owner puede llamar a la funci\u00f3n. modifier onlyOwner() { require(msg.sender == owner, You are not the owner. ); _; } onlySu() Solo la direcci\u00f3n que tenga el rol de superUser puede llamar a la funci\u00f3n. modifier onlySu() { require(msg.sender == superUser, You are not the super user. ); _; } Funciones constructor() En el momento de la creaci\u00f3n del contrato, se asigna el rol de owner y super usuario a la direcci\u00f3n que haya desplegado el contrato. constructor() public { owner = msg.sender; superUser = msg.sender; } transferSuperUser() El poseedor de los permisos superUsuario transfiere sus permisos a una nueva direcci\u00f3n. function transferSuperUser(address _newSu) public onlySu { require(_newSu != address(0), Adress can't be 0x0000... ); emit SuperUserTransferred(superUser, _newSu); superUser = _newSu; } Argumentos _newSu address Direcci\u00f3n del nuevo super usuario. renounceOwnership() El owner asigna sus permisos a la cuenta 0x000... dejando de ser el owner. function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } transferOwnership() El poseedor de los permisos superUsuario cambia los permisos de owner a la direcci\u00f3n proporcionada. function transferOwnership(address _newOwner) public onlySu { require(_newOwner != address(0), Adress can't be 0x0000... ); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } Argumentos _newOwner address Direcci\u00f3n del nuevo owner.","title":"Ownable"},{"location":"ownable/#variables","text":"owner address public superUser address public","title":"Variables"},{"location":"ownable/#eventos","text":"event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); event SuperUserTransferred( address indexed previousSu, address indexed newSu );","title":"Eventos"},{"location":"ownable/#modificadores","text":"","title":"Modificadores"},{"location":"ownable/#onlyowner","text":"Solo la direcci\u00f3n que tenga el rol de owner puede llamar a la funci\u00f3n. modifier onlyOwner() { require(msg.sender == owner, You are not the owner. ); _; }","title":"onlyOwner()"},{"location":"ownable/#onlysu","text":"Solo la direcci\u00f3n que tenga el rol de superUser puede llamar a la funci\u00f3n. modifier onlySu() { require(msg.sender == superUser, You are not the super user. ); _; }","title":"onlySu()"},{"location":"ownable/#funciones","text":"","title":"Funciones"},{"location":"ownable/#constructor","text":"En el momento de la creaci\u00f3n del contrato, se asigna el rol de owner y super usuario a la direcci\u00f3n que haya desplegado el contrato. constructor() public { owner = msg.sender; superUser = msg.sender; }","title":"constructor()"},{"location":"ownable/#transfersuperuser","text":"El poseedor de los permisos superUsuario transfiere sus permisos a una nueva direcci\u00f3n. function transferSuperUser(address _newSu) public onlySu { require(_newSu != address(0), Adress can't be 0x0000... ); emit SuperUserTransferred(superUser, _newSu); superUser = _newSu; } Argumentos _newSu address Direcci\u00f3n del nuevo super usuario.","title":"transferSuperUser()"},{"location":"ownable/#renounceownership","text":"El owner asigna sus permisos a la cuenta 0x000... dejando de ser el owner. function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); }","title":"renounceOwnership()"},{"location":"ownable/#transferownership","text":"El poseedor de los permisos superUsuario cambia los permisos de owner a la direcci\u00f3n proporcionada. function transferOwnership(address _newOwner) public onlySu { require(_newOwner != address(0), Adress can't be 0x0000... ); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } Argumentos _newOwner address Direcci\u00f3n del nuevo owner.","title":"transferOwnership()"},{"location":"teur/","text":"TEUR - Tikebit Euro La funcionalidad del TEUR es sencilla, ya que es un token ERC20 con todas las funcionalidades de las interfaces ERC20Basic y ERC20 , adem\u00e1s de incluir mint y burn . Variables name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal TKBabi TKB public Mappings El mapping de \"balances\" es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de \"allowed\" guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed; Eventos event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event TKBfee(uint256 amount); Funciones constructor() En el momento de la creaci\u00f3n del contrato, al ser desplegado por el smart contract TKB, teniendo la ABI ya, vinculamos el msg.sender al ABI y tambi\u00e9n le transfiere los permisos a la direcci\u00f3n de _owner . constructor(address _owner) public { TKBabi = TKB(msg.sender); Ownable.transferOwnership(_owner); Ownable.transferSuperUser(_owner); } Argumentos owner address Direcci\u00f3n del nuevo owner y superUser . burn() Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB. Comprueba que _amount no es 0 y que el msg.sender tiene suficiente balance. Despu\u00e9s calcula y asigna el % correspondiente al TKB y despu\u00e9s resta el _amount al msg.sender y resta de totalSupply_ el restante del _amount sin la cantidad enviada al TKB. function burn( uint256 _amount ) public onlyOwner returns (bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender], Insufficient balance. ); address _who = msg.sender; uint256 _amountForTKB = _amount.mul(150).div(10000); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); uint256 _amountWithoutFee = _amount.sub(_amountForTKB); balances[_who] = balances[_who].sub(_amountWithoutFee); totalSupply_ = totalSupply_.sub(_amountWithoutFee); emit Burn(_who, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. mint() Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB y se quitar\u00e1 un Y% correspondiente a la comisi\u00f3n de la tienda que cre\u00f3 el tiket. Comprueba que _amount no es 0, que _to no sea 0x000... y que _fee es mayor que 0 y menor que 500. Despu\u00e9s, calcula y quita la cantidad que se queda el CashNode y calcula la cantidad que se va al TKB y se lo asigna. Una vez ya se han sacado todas las comisiones, se aumenta el totalSupply_ y se le asignan los tokens restantes de _amount . function mint( address _to, uint256 _amount, uint256 _fee ) public onlyOwner returns (bool) { require(_amount 0, Amount must be more than 0 ); require(_to != address(0), You can't send tokens to this address ); require(_fee 0, Fees must be more than 0 ); require(_fee 500, Fees must be lower than 5%-500 units ); uint256 _amountCashNodeFee = _amount.mul(_fee).div(10000); uint256 _amountWithoutFee = _amount.sub(_amountCashNodeFee); totalSupply_ = totalSupply_.add(_amount); uint256 _amountForTKB = _amount.mul(150).div(10000); _amountWithoutFee = _amount.sub(_amountForTKB); balances[_to] = balances[_to].add(_amountWithoutFee); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); emit Mint(_to, _amountWithoutFee); emit TKBfee(_amountForTKB); emit Transfer(address(0), _to, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens a crear. _fee uint256 Cantidad de tokens que se queda el CashNode. _to address Direcci\u00f3n a la que enviar los tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. totalSupply() Devuelve el total de tokens que hay. (Devuelve el totalSupply_ ) function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen. transfer() Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance. Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender], Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir. balanceOf() Devuelve la cantidad de tokens que tiene _owner . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner]; } Argumentos _owner address Direcci\u00f3n de quien devolver el balance. transferFrom() Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from], Insufficient balance. ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. approve() El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. allowance() Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida. increaseApproval() Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. decreaseApproval() Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"TEUR"},{"location":"teur/#teur-tikebit-euro","text":"La funcionalidad del TEUR es sencilla, ya que es un token ERC20 con todas las funcionalidades de las interfaces ERC20Basic y ERC20 , adem\u00e1s de incluir mint y burn .","title":"TEUR - Tikebit Euro"},{"location":"teur/#variables","text":"name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal TKBabi TKB public","title":"Variables"},{"location":"teur/#mappings","text":"El mapping de \"balances\" es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de \"allowed\" guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed;","title":"Mappings"},{"location":"teur/#eventos","text":"event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event TKBfee(uint256 amount);","title":"Eventos"},{"location":"teur/#funciones","text":"","title":"Funciones"},{"location":"teur/#constructor","text":"En el momento de la creaci\u00f3n del contrato, al ser desplegado por el smart contract TKB, teniendo la ABI ya, vinculamos el msg.sender al ABI y tambi\u00e9n le transfiere los permisos a la direcci\u00f3n de _owner . constructor(address _owner) public { TKBabi = TKB(msg.sender); Ownable.transferOwnership(_owner); Ownable.transferSuperUser(_owner); } Argumentos owner address Direcci\u00f3n del nuevo owner y superUser .","title":"constructor()"},{"location":"teur/#burn","text":"Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB. Comprueba que _amount no es 0 y que el msg.sender tiene suficiente balance. Despu\u00e9s calcula y asigna el % correspondiente al TKB y despu\u00e9s resta el _amount al msg.sender y resta de totalSupply_ el restante del _amount sin la cantidad enviada al TKB. function burn( uint256 _amount ) public onlyOwner returns (bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender], Insufficient balance. ); address _who = msg.sender; uint256 _amountForTKB = _amount.mul(150).div(10000); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); uint256 _amountWithoutFee = _amount.sub(_amountForTKB); balances[_who] = balances[_who].sub(_amountWithoutFee); totalSupply_ = totalSupply_.sub(_amountWithoutFee); emit Burn(_who, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"burn()"},{"location":"teur/#mint","text":"Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB y se quitar\u00e1 un Y% correspondiente a la comisi\u00f3n de la tienda que cre\u00f3 el tiket. Comprueba que _amount no es 0, que _to no sea 0x000... y que _fee es mayor que 0 y menor que 500. Despu\u00e9s, calcula y quita la cantidad que se queda el CashNode y calcula la cantidad que se va al TKB y se lo asigna. Una vez ya se han sacado todas las comisiones, se aumenta el totalSupply_ y se le asignan los tokens restantes de _amount . function mint( address _to, uint256 _amount, uint256 _fee ) public onlyOwner returns (bool) { require(_amount 0, Amount must be more than 0 ); require(_to != address(0), You can't send tokens to this address ); require(_fee 0, Fees must be more than 0 ); require(_fee 500, Fees must be lower than 5%-500 units ); uint256 _amountCashNodeFee = _amount.mul(_fee).div(10000); uint256 _amountWithoutFee = _amount.sub(_amountCashNodeFee); totalSupply_ = totalSupply_.add(_amount); uint256 _amountForTKB = _amount.mul(150).div(10000); _amountWithoutFee = _amount.sub(_amountForTKB); balances[_to] = balances[_to].add(_amountWithoutFee); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); emit Mint(_to, _amountWithoutFee); emit TKBfee(_amountForTKB); emit Transfer(address(0), _to, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens a crear. _fee uint256 Cantidad de tokens que se queda el CashNode. _to address Direcci\u00f3n a la que enviar los tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"mint()"},{"location":"teur/#totalsupply","text":"Devuelve el total de tokens que hay. (Devuelve el totalSupply_ ) function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen.","title":"totalSupply()"},{"location":"teur/#transfer","text":"Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance. Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender], Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir.","title":"transfer()"},{"location":"teur/#balanceof","text":"Devuelve la cantidad de tokens que tiene _owner . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner]; } Argumentos _owner address Direcci\u00f3n de quien devolver el balance.","title":"balanceOf()"},{"location":"teur/#transferfrom","text":"Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from], Insufficient balance. ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"transferFrom()"},{"location":"teur/#approve","text":"El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"approve()"},{"location":"teur/#allowance","text":"Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida.","title":"allowance()"},{"location":"teur/#increaseapproval","text":"Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"increaseApproval()"},{"location":"teur/#decreaseapproval","text":"Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"decreaseApproval()"},{"location":"tkb/","text":"TKB - Tikebit Coin El TKB implementa las funcionalidades de ERC20Basic y ERC20 . La finalidad de este token es permitir el reparto de las fee que se generan en el TEUR . Para conseguir esto, se podr\u00e1n generar stakes , que contienen stakeUnits las cuales representan las unidades proporcionales que recibir\u00e1s respecto a la feePool . Tambi\u00e9n se implementa un sistema de fechas donde est\u00e1 todo controlado para que se restrinja cada acci\u00f3n a determinada fecha. Los tokens usados en los stakes se restar\u00e1n del balance de la direcci\u00f3n en funciones como transfer() , transferFrom() y las que requieran saber del balance de tokens de una direcci\u00f3n. Las transferencias estar\u00e1n congeladas hasta que se termine la ICO, la variable que controla esto es stopped . Es posible que una vez terminada la ICO se vuelva a para el contrato, pero solo en el caso de que se pida un refund de la DAICO, permitiendo as\u00ed ir al contrato de la DAICO a retirar ETH a raz\u00f3n de los tokens TKB que tengas. Esta variable no es posible cambiarla de forma manual, se descongelar\u00e1 una vez termine la ICO de forma autom\u00e1tica y al pedir un refund mediante la DAO. Variables name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal totalFeeCollected uint256 public totalFeeWithdrawn uint256 public dateWeek uint256 public pricePerStakeUnit uint256 public constant amountStakeUnits uint256 public stopped bool public DAICOaddress address public TEURaddress address public VestingAddress address public DAICOabi DAICO public TEURabi TEUR public VestingAbi Vesting public Structs Un Stake est\u00e1 asociado a una direcci\u00f3n, lo cual permite saber la \u00faltima vez que retir\u00f3 fees, cuantos tokens tiene en stake y tiene un array de Units que representa la cantidad de unidades que tiene en stake. struct Stake { uint256 tokensStaked; uint256 dateLastWithdraw; Units[] stakeUnits; } Cuando hablamos de Units , se refiere a la cantidad de pricePerStakeUnit que se han puesto en stake. En este struct, contiene dos valores, la fecha en la que se podr\u00e1 hacer undoStake y la cantidad de unidades que se utilizaron. struct Units { uint256 dateToUnstake; uint256 stakedUnits; } Mappings El mapping de balances es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de allowed guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed; El mapping stake asigna una direcci\u00f3n a un struct Stake . mapping(address = Stake) public stake; Historial de cuanto fee se ha recaudado, asignando la fecha a la cantidad. mapping(uint256 = uint256) internal feesPerWeek; Funciones constructor() En el momento de la creaci\u00f3n del contrato, se desplegar\u00e1 el contrato TEUR , haciendo eso, se guardar\u00e1 la direcci\u00f3n del contrato y se guardar\u00e1 la direcci\u00f3n asociada con la ABI, para poder llamar de forma m\u00e1s sencilla a ese contrato en el futuro. constructor() public { // DAICOaddress = new DAICO(msg.sender, address(this), block.timestamp.add(6 hours)); // DAICOabi = DAICO(DAICOaddress); TEURaddress = new TEUR(msg.sender); TEURabi = TEUR(TEURaddress); // VestingAddress = new Vesting(msg.sender); // VestingAbi = Vesting(VestingAddress); // -- AQU\u00cd HAY QUE DECLARAR MUCHAS VARIABLES Y DECIDIR EL REPARTO INICIAL DE TKB } createStake() La funci\u00f3n est\u00e1 separada en dos para facilitar la auditabilidad del c\u00f3digo, ya que en la primera parte se realizan todas las comprobaciones y en el segundo las acciones. Primero se comprueban las fechas. La direcci\u00f3n tiene que retirar todas las fees hasta la fecha y no se puede hacer stake fuera de las horas indicadas. Despu\u00e9s se calculan las cantidades y se comprueba que la direcci\u00f3n tenga suficiente balance. En la parte de la acci\u00f3n, se incrementan los tokensStaked de la direcci\u00f3n y se a\u00f1ade un struct Units al array de stakeUnits . function createStake( uint256 _unitsToStake ) public { require(stake[msg.sender].dateLastWithdraw == dateWeek || stake[msg.sender].dateLastWithdraw == 0, Withdraw previous fees before staking ); require(block.timestamp = dateWeek.add(2 hours) block.timestamp = dateWeek.add(1 days), It's not time to stake yet ); require(_unitsToStake 0, Units must be more than 1. ); uint256 _amount = _unitsToStake.mul(pricePerStakeUnit); require(balanceOf(msg.sender) = _amount, Insufficient balance ); _createStake(_amount, _unitsToStake, msg.sender); } function _createStake( uint256 _amountToStake, uint256 _unitsToStake, address _user ) internal { stake[_user].tokensStaked = stake[_user].tokensStaked.add(_amountToStake); stake[_user].stakeUnits.push(Units(block.timestamp, _amountToStake)); stake[_user].dateLastWithdraw = dateWeek.add(1 weeks); amountStakeUnits = amountStakeUnits.add(_unitsToStake); } Argumentos _unitsToStake uint256 Cantidad de unidades a incrementar el stake. undoStake() La funci\u00f3n est\u00e1 separada en dos para facilitar la auditabilidad del c\u00f3digo, ya que en la primera parte se realizan todas las comprobaciones y en el segundo las acciones. El array de Units est\u00e1ordenado cronologicamente, donde la posici\u00f3n 0 siempre ser\u00e1n las stakeUnits que antes podr\u00e1s retirar, as\u00ed que la funci\u00f3n siempre apunta a la posici\u00f3n 0. Primero se comprueban las fechas. La direcci\u00f3n tiene que retirar todas las fees hasta la fecha y si las stakeUnits en la posici\u00f3n 0 se pueden retirar. Despues se comprueban las cantidades para saber si se han especificado _unitsToUndoStake mayores que 0 y si es mayor de la cantidad que tiene la direcci\u00f3n en stake. En la parte de la acci\u00f3n, se realiza un bucle donde se sigue el siguiente comportamiento cada iteraci\u00f3n: - Si la posici\u00f3n 0 se puede retirar, comprobando la fecha ( dateToUnstake ) y si _rUnits (unidades restantes) no es 0. - Si se puede, comprueba que las _rUnits , son mayores que el stakedUnits de la posici\u00f3n 0. - Si es mayor, se elimina el elemento del array, se restan las unidades al _rUnits y se vuelve a empezar. - Si es menor, se resta a stakedUnits las _rUnits y se pone a 0. En el caso de que la posici\u00f3n 0 no se pueda retirar o _rUnits sea 0, se termina el bucle y se procede a actualizar los tokensStaked de la direcci\u00f3n y se resta las unidades usadas del total amountStakeUnits . function undoStake( uint256 _unitsToUndoStake ) public { require(stake[msg.sender].dateLastWithdraw == dateWeek, You need to withdraw the fees first ); require(stake[msg.sender].stakeUnits[0].dateToUnstake = block.timestamp, You can't unstake yet ); require(_unitsToUndoStake 0, Units must be more than 0. ); uint256 _amount = _unitsToUndoStake.mul(pricePerStakeUnit); require(stake[msg.sender].tokensStaked = _amount, You are trying to unstake more than you have. ); _undoStake(_unitsToUndoStake, msg.sender); } function _undoStake( uint256 _unitsToUndoStake, address _user ) internal { uint _rUnits = _unitsToUndoStake; for(uint i = 0; i 40; i++){ if(_rUnits 0 stake[_user].stakeUnits[0].dateToUnstake = block.timestamp) { if (stake[_user].stakeUnits[0].stakedUnits = _rUnits) { _rUnits = _rUnits.sub(stake[_user].stakeUnits[0].stakedUnits); removeStakeUnit(0, _user); } else { stake[_user].stakeUnits[0].stakedUnits = stake[_user].stakeUnits[0].stakedUnits.sub(_unitsToUndoStake); _rUnits = 0; } } else { break; } } uint _usedUnits = _unitsToUndoStake.sub(_rUnits); stake[_user].tokensStaked = stake[_user].tokensStaked.sub(_usedUnits.mul(pricePerStakeUnit)); amountStakeUnits = amountStakeUnits.sub(_usedUnits); } Argumentos _unitsToUndoStake uint256 Cantidad de unidades a reducir el stake. removeStakeUnit() Funci\u00f3n interna usada por el undoStake() para eliminar la primera entrada del array. function removeStakeUnit( uint _index, address _user ) internal { for (uint i = _index; i stake[msg.sender].stakeUnits.length-1; i++){ stake[_user].stakeUnits[i] = stake[_user].stakeUnits[i+1]; } stake[_user].stakeUnits.length--; } Argumentos _index uint256 Posici\u00f3n a eliminar del array. _user address Direcci\u00f3n a la cual reducir el array. calculateWeeklyFees() Una vez a la semana, se puede llamar a esta funci\u00f3n para calcular cuanto fee se le ha asignado solo en la \u00faltima semana. Primero comprueba que haya pasado una semana desde la \u00faltima vez que se calcul\u00f3( dateWeek ). Despu\u00e9s se a\u00f1ade 1 semana a dateWeek y se pide la cantidad de tokens TEUR que tiene el TKB . Con eso, se calcula las fees que son de la \u00faltima semana usando el balanceTEUR , la cantidad de fees que se han retirado ( totalFeeWithdrawn ) y la suma de todas las fees hasta la fecha( totalFeeCollected ). Una vez calculado, se divide por la cantidad de stakeUnits que hay en ese momento y se guarda el valor por unidad en el mapping feesPerWeek . Tambi\u00e9n se a\u00f1ade las fee de esta semana al totalFeeCollected . function calculateWeeklyFees() public { require(block.timestamp = dateWeek+1 weeks, You can't do this yet. ); dateWeek = dateWeek.add(1 weeks); uint256 balanceTEUR = TEURabi.balanceOf(this); uint256 _fee = (balanceTEUR.add(totalFeeWithdrawn)).sub(totalFeeCollected); uint256 _feePerUser = _fee.div(amountStakeUnits); totalFeeCollected = totalFeeCollected.add(_fee); feesPerWeek[dateWeek] = _feePerUser; } withdrawFees() Al llamar a esta funci\u00f3n, se retirar\u00e1n las fees asignadas a la direcci\u00f3n que llama de forma autom\u00e1tica. Hay un l\u00edmite de 40 semanas para cobrar, ya que al poner m\u00e1s, puede fallar por el coste elevado de gas de los bucles. Primero se comprueba que la direcci\u00f3n no es 0x000..., que la direcci\u00f3n tenga alg\u00fan stakeUnit y si tiene fees sin retirar. En el bucle, se comprueba si la dateLastWithdraw es menor o igual que dateWeek . Si lo es, se calculan las fees que le corresponden en feesPerWeek[_dateUser] y se le suma 1 semana a _dateUser . Cuando la comprobaci\u00f3n falla, se sale del bucle y se asigna la _dateUser a la dateLastWithdraw , la cual ser\u00e1 dateWeek + 1 semana. Y por \u00faltimo, se le envian desde el TEUR la cantidad total de fees calculada por el bucle. function withdrawFees() public { address _user = msg.sender; require(_user != address(0), Adress can't be 0x0000... ); require(stake[_user].tokensStaked 0, You don't have any stake unit. ); require(stake[_user].dateLastWithdraw = dateWeek, You don't have fees to withdraw. ); uint256 _units = stake[_user].tokensStaked.div(pricePerStakeUnit.mul(decimals)); uint256 _amountFees = 0; uint256 _dateUser = stake[_user].dateLastWithdraw; for (uint256 i = 1; i = 40; i++) { if (_dateUser = dateWeek) { _amountFees = (_amountFees.add(feesPerWeek[_dateUser])).mul(_units); _dateUser = _dateUser.add(1 weeks); } else { break; } } assert(_amountFees 0); stake[_user].dateLastWithdraw = _dateUser; TEURabi.transfer(_user, _amountFees); } getStakeUnits() Devuelve la cantidad de stakeUnits que tiene una direcci\u00f3n. function getStakeUnits( address _user ) public view returns (uint) { return stake[_user].tokensStaked.div(pricePerStakeUnit); } Argumentos _user uint256 Direcci\u00f3n de la cual saber la cantidad de units. freezeTransfer() Solo el contrato de la DAICO puede llamar a esta funci\u00f3n. Al llamar, stopped se pone en true, lo que hace que se congelen las transferencias. function freezeTransfer() public { require(msg.sender == DAICOaddress, Must be called by the DAICO contract. ); stopped = true; } unfreezeTransfer() Solo el contrato de la DAICO puede llamar a esta funci\u00f3n. Al llamar, stopped se pone en false, lo que hace que se descongelen las transferencias. function freezeTransfer() public { require(msg.sender == DAICOaddress, Must be called by the DAICO contract. ); stopped = false; } totalSupply() Devuelve el total de tokens que hay. (Devuelve el totalSupply_ ) function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen. transfer() Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance, restando la cantidad que tiene en stake . Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(!stopped, Transfers are paused. ); require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender].sub(stake[msg.sender].tokensStaked), Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir. balanceOf() Devuelve la cantidad de tokens que tiene _owner , restando la cantidad que tiene en stake . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner].sub(stake[_owner].tokensStaked); } Argumentos _owner address Direcci\u00f3n de quien devolver el balance. transferFrom() Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance, restando la cantidad que tiene en stake y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(!stopped, Transfers are paused. ); require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from].sub(stake[msg.sender].tokensStaked), Insufficient balance ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. approve() El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { require(_value != 0, Value must be more than 0. ); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. allowance() Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida. increaseApproval() Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. decreaseApproval() Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. burn() Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB. Comprueba que _amount no es 0 y que el msg.sender tiene suficiente balance. Despu\u00e9s calcula y asigna el % correspondiente al TKB y despu\u00e9s resta el _amount al msg.sender y resta de totalSupply_ el restante del _amount sin la cantidad enviada al TKB. function burn( uint256 _amount ) public onlyOwner returns (bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender], Insufficient balance. ); address _who = msg.sender; uint256 _amountForTKB = _amount.mul(150).div(10000); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); uint256 _amountWithoutFee = _amount.sub(_amountForTKB); balances[_who] = balances[_who].sub(_amountWithoutFee); totalSupply_ = totalSupply_.sub(_amountWithoutFee); emit Burn(_who, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. mint() Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB y se quitar\u00e1 un Y% correspondiente a la comisi\u00f3n de la tienda que cre\u00f3 el tiket. Comprueba que _amount no es 0, que _to no sea 0x000... y que _fee es mayor que 0 y menor que 500. Despu\u00e9s, calcula y quita la cantidad que se queda el CashNode y calcula la cantidad que se va al TKB y se lo asigna. Una vez ya se han sacado todas las comisiones, se aumenta el totalSupply_ y se le asignan los tokens restantes de _amount . function mint( address _to, uint256 _amount, uint256 _fee ) public onlyOwner returns (bool) { require(_amount 0, Amount must be more than 0 ); require(_to != address(0), You can't send tokens to this address ); require(_fee 0, Fees must be more than 0 ); require(_fee 500, Fees must be lower than 5%-500 units ); uint256 _amountCashNodeFee = _amount.mul(_fee).div(10000); uint256 _amountWithoutFee = _amount.sub(_amountCashNodeFee); totalSupply_ = totalSupply_.add(_amount); uint256 _amountForTKB = _amount.mul(150).div(10000); _amountWithoutFee = _amount.sub(_amountForTKB); balances[_to] = balances[_to].add(_amountWithoutFee); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); emit Mint(_to, _amountWithoutFee); emit TKBfee(_amountForTKB); emit Transfer(address(0), _to, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens a crear. _fee uint256 Cantidad de tokens que se queda el CashNode. _to address Direcci\u00f3n a la que enviar los tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"TKB"},{"location":"tkb/#tkb-tikebit-coin","text":"El TKB implementa las funcionalidades de ERC20Basic y ERC20 . La finalidad de este token es permitir el reparto de las fee que se generan en el TEUR . Para conseguir esto, se podr\u00e1n generar stakes , que contienen stakeUnits las cuales representan las unidades proporcionales que recibir\u00e1s respecto a la feePool . Tambi\u00e9n se implementa un sistema de fechas donde est\u00e1 todo controlado para que se restrinja cada acci\u00f3n a determinada fecha. Los tokens usados en los stakes se restar\u00e1n del balance de la direcci\u00f3n en funciones como transfer() , transferFrom() y las que requieran saber del balance de tokens de una direcci\u00f3n. Las transferencias estar\u00e1n congeladas hasta que se termine la ICO, la variable que controla esto es stopped . Es posible que una vez terminada la ICO se vuelva a para el contrato, pero solo en el caso de que se pida un refund de la DAICO, permitiendo as\u00ed ir al contrato de la DAICO a retirar ETH a raz\u00f3n de los tokens TKB que tengas. Esta variable no es posible cambiarla de forma manual, se descongelar\u00e1 una vez termine la ICO de forma autom\u00e1tica y al pedir un refund mediante la DAO.","title":"TKB - Tikebit Coin"},{"location":"tkb/#variables","text":"name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal totalFeeCollected uint256 public totalFeeWithdrawn uint256 public dateWeek uint256 public pricePerStakeUnit uint256 public constant amountStakeUnits uint256 public stopped bool public DAICOaddress address public TEURaddress address public VestingAddress address public DAICOabi DAICO public TEURabi TEUR public VestingAbi Vesting public","title":"Variables"},{"location":"tkb/#structs","text":"Un Stake est\u00e1 asociado a una direcci\u00f3n, lo cual permite saber la \u00faltima vez que retir\u00f3 fees, cuantos tokens tiene en stake y tiene un array de Units que representa la cantidad de unidades que tiene en stake. struct Stake { uint256 tokensStaked; uint256 dateLastWithdraw; Units[] stakeUnits; } Cuando hablamos de Units , se refiere a la cantidad de pricePerStakeUnit que se han puesto en stake. En este struct, contiene dos valores, la fecha en la que se podr\u00e1 hacer undoStake y la cantidad de unidades que se utilizaron. struct Units { uint256 dateToUnstake; uint256 stakedUnits; }","title":"Structs"},{"location":"tkb/#mappings","text":"El mapping de balances es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de allowed guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed; El mapping stake asigna una direcci\u00f3n a un struct Stake . mapping(address = Stake) public stake; Historial de cuanto fee se ha recaudado, asignando la fecha a la cantidad. mapping(uint256 = uint256) internal feesPerWeek;","title":"Mappings"},{"location":"tkb/#funciones","text":"","title":"Funciones"},{"location":"tkb/#constructor","text":"En el momento de la creaci\u00f3n del contrato, se desplegar\u00e1 el contrato TEUR , haciendo eso, se guardar\u00e1 la direcci\u00f3n del contrato y se guardar\u00e1 la direcci\u00f3n asociada con la ABI, para poder llamar de forma m\u00e1s sencilla a ese contrato en el futuro. constructor() public { // DAICOaddress = new DAICO(msg.sender, address(this), block.timestamp.add(6 hours)); // DAICOabi = DAICO(DAICOaddress); TEURaddress = new TEUR(msg.sender); TEURabi = TEUR(TEURaddress); // VestingAddress = new Vesting(msg.sender); // VestingAbi = Vesting(VestingAddress); // -- AQU\u00cd HAY QUE DECLARAR MUCHAS VARIABLES Y DECIDIR EL REPARTO INICIAL DE TKB }","title":"constructor()"},{"location":"tkb/#createstake","text":"La funci\u00f3n est\u00e1 separada en dos para facilitar la auditabilidad del c\u00f3digo, ya que en la primera parte se realizan todas las comprobaciones y en el segundo las acciones. Primero se comprueban las fechas. La direcci\u00f3n tiene que retirar todas las fees hasta la fecha y no se puede hacer stake fuera de las horas indicadas. Despu\u00e9s se calculan las cantidades y se comprueba que la direcci\u00f3n tenga suficiente balance. En la parte de la acci\u00f3n, se incrementan los tokensStaked de la direcci\u00f3n y se a\u00f1ade un struct Units al array de stakeUnits . function createStake( uint256 _unitsToStake ) public { require(stake[msg.sender].dateLastWithdraw == dateWeek || stake[msg.sender].dateLastWithdraw == 0, Withdraw previous fees before staking ); require(block.timestamp = dateWeek.add(2 hours) block.timestamp = dateWeek.add(1 days), It's not time to stake yet ); require(_unitsToStake 0, Units must be more than 1. ); uint256 _amount = _unitsToStake.mul(pricePerStakeUnit); require(balanceOf(msg.sender) = _amount, Insufficient balance ); _createStake(_amount, _unitsToStake, msg.sender); } function _createStake( uint256 _amountToStake, uint256 _unitsToStake, address _user ) internal { stake[_user].tokensStaked = stake[_user].tokensStaked.add(_amountToStake); stake[_user].stakeUnits.push(Units(block.timestamp, _amountToStake)); stake[_user].dateLastWithdraw = dateWeek.add(1 weeks); amountStakeUnits = amountStakeUnits.add(_unitsToStake); } Argumentos _unitsToStake uint256 Cantidad de unidades a incrementar el stake.","title":"createStake()"},{"location":"tkb/#undostake","text":"La funci\u00f3n est\u00e1 separada en dos para facilitar la auditabilidad del c\u00f3digo, ya que en la primera parte se realizan todas las comprobaciones y en el segundo las acciones. El array de Units est\u00e1ordenado cronologicamente, donde la posici\u00f3n 0 siempre ser\u00e1n las stakeUnits que antes podr\u00e1s retirar, as\u00ed que la funci\u00f3n siempre apunta a la posici\u00f3n 0. Primero se comprueban las fechas. La direcci\u00f3n tiene que retirar todas las fees hasta la fecha y si las stakeUnits en la posici\u00f3n 0 se pueden retirar. Despues se comprueban las cantidades para saber si se han especificado _unitsToUndoStake mayores que 0 y si es mayor de la cantidad que tiene la direcci\u00f3n en stake. En la parte de la acci\u00f3n, se realiza un bucle donde se sigue el siguiente comportamiento cada iteraci\u00f3n: - Si la posici\u00f3n 0 se puede retirar, comprobando la fecha ( dateToUnstake ) y si _rUnits (unidades restantes) no es 0. - Si se puede, comprueba que las _rUnits , son mayores que el stakedUnits de la posici\u00f3n 0. - Si es mayor, se elimina el elemento del array, se restan las unidades al _rUnits y se vuelve a empezar. - Si es menor, se resta a stakedUnits las _rUnits y se pone a 0. En el caso de que la posici\u00f3n 0 no se pueda retirar o _rUnits sea 0, se termina el bucle y se procede a actualizar los tokensStaked de la direcci\u00f3n y se resta las unidades usadas del total amountStakeUnits . function undoStake( uint256 _unitsToUndoStake ) public { require(stake[msg.sender].dateLastWithdraw == dateWeek, You need to withdraw the fees first ); require(stake[msg.sender].stakeUnits[0].dateToUnstake = block.timestamp, You can't unstake yet ); require(_unitsToUndoStake 0, Units must be more than 0. ); uint256 _amount = _unitsToUndoStake.mul(pricePerStakeUnit); require(stake[msg.sender].tokensStaked = _amount, You are trying to unstake more than you have. ); _undoStake(_unitsToUndoStake, msg.sender); } function _undoStake( uint256 _unitsToUndoStake, address _user ) internal { uint _rUnits = _unitsToUndoStake; for(uint i = 0; i 40; i++){ if(_rUnits 0 stake[_user].stakeUnits[0].dateToUnstake = block.timestamp) { if (stake[_user].stakeUnits[0].stakedUnits = _rUnits) { _rUnits = _rUnits.sub(stake[_user].stakeUnits[0].stakedUnits); removeStakeUnit(0, _user); } else { stake[_user].stakeUnits[0].stakedUnits = stake[_user].stakeUnits[0].stakedUnits.sub(_unitsToUndoStake); _rUnits = 0; } } else { break; } } uint _usedUnits = _unitsToUndoStake.sub(_rUnits); stake[_user].tokensStaked = stake[_user].tokensStaked.sub(_usedUnits.mul(pricePerStakeUnit)); amountStakeUnits = amountStakeUnits.sub(_usedUnits); } Argumentos _unitsToUndoStake uint256 Cantidad de unidades a reducir el stake.","title":"undoStake()"},{"location":"tkb/#removestakeunit","text":"Funci\u00f3n interna usada por el undoStake() para eliminar la primera entrada del array. function removeStakeUnit( uint _index, address _user ) internal { for (uint i = _index; i stake[msg.sender].stakeUnits.length-1; i++){ stake[_user].stakeUnits[i] = stake[_user].stakeUnits[i+1]; } stake[_user].stakeUnits.length--; } Argumentos _index uint256 Posici\u00f3n a eliminar del array. _user address Direcci\u00f3n a la cual reducir el array.","title":"removeStakeUnit()"},{"location":"tkb/#calculateweeklyfees","text":"Una vez a la semana, se puede llamar a esta funci\u00f3n para calcular cuanto fee se le ha asignado solo en la \u00faltima semana. Primero comprueba que haya pasado una semana desde la \u00faltima vez que se calcul\u00f3( dateWeek ). Despu\u00e9s se a\u00f1ade 1 semana a dateWeek y se pide la cantidad de tokens TEUR que tiene el TKB . Con eso, se calcula las fees que son de la \u00faltima semana usando el balanceTEUR , la cantidad de fees que se han retirado ( totalFeeWithdrawn ) y la suma de todas las fees hasta la fecha( totalFeeCollected ). Una vez calculado, se divide por la cantidad de stakeUnits que hay en ese momento y se guarda el valor por unidad en el mapping feesPerWeek . Tambi\u00e9n se a\u00f1ade las fee de esta semana al totalFeeCollected . function calculateWeeklyFees() public { require(block.timestamp = dateWeek+1 weeks, You can't do this yet. ); dateWeek = dateWeek.add(1 weeks); uint256 balanceTEUR = TEURabi.balanceOf(this); uint256 _fee = (balanceTEUR.add(totalFeeWithdrawn)).sub(totalFeeCollected); uint256 _feePerUser = _fee.div(amountStakeUnits); totalFeeCollected = totalFeeCollected.add(_fee); feesPerWeek[dateWeek] = _feePerUser; }","title":"calculateWeeklyFees()"},{"location":"tkb/#withdrawfees","text":"Al llamar a esta funci\u00f3n, se retirar\u00e1n las fees asignadas a la direcci\u00f3n que llama de forma autom\u00e1tica. Hay un l\u00edmite de 40 semanas para cobrar, ya que al poner m\u00e1s, puede fallar por el coste elevado de gas de los bucles. Primero se comprueba que la direcci\u00f3n no es 0x000..., que la direcci\u00f3n tenga alg\u00fan stakeUnit y si tiene fees sin retirar. En el bucle, se comprueba si la dateLastWithdraw es menor o igual que dateWeek . Si lo es, se calculan las fees que le corresponden en feesPerWeek[_dateUser] y se le suma 1 semana a _dateUser . Cuando la comprobaci\u00f3n falla, se sale del bucle y se asigna la _dateUser a la dateLastWithdraw , la cual ser\u00e1 dateWeek + 1 semana. Y por \u00faltimo, se le envian desde el TEUR la cantidad total de fees calculada por el bucle. function withdrawFees() public { address _user = msg.sender; require(_user != address(0), Adress can't be 0x0000... ); require(stake[_user].tokensStaked 0, You don't have any stake unit. ); require(stake[_user].dateLastWithdraw = dateWeek, You don't have fees to withdraw. ); uint256 _units = stake[_user].tokensStaked.div(pricePerStakeUnit.mul(decimals)); uint256 _amountFees = 0; uint256 _dateUser = stake[_user].dateLastWithdraw; for (uint256 i = 1; i = 40; i++) { if (_dateUser = dateWeek) { _amountFees = (_amountFees.add(feesPerWeek[_dateUser])).mul(_units); _dateUser = _dateUser.add(1 weeks); } else { break; } } assert(_amountFees 0); stake[_user].dateLastWithdraw = _dateUser; TEURabi.transfer(_user, _amountFees); }","title":"withdrawFees()"},{"location":"tkb/#getstakeunits","text":"Devuelve la cantidad de stakeUnits que tiene una direcci\u00f3n. function getStakeUnits( address _user ) public view returns (uint) { return stake[_user].tokensStaked.div(pricePerStakeUnit); } Argumentos _user uint256 Direcci\u00f3n de la cual saber la cantidad de units.","title":"getStakeUnits()"},{"location":"tkb/#freezetransfer","text":"Solo el contrato de la DAICO puede llamar a esta funci\u00f3n. Al llamar, stopped se pone en true, lo que hace que se congelen las transferencias. function freezeTransfer() public { require(msg.sender == DAICOaddress, Must be called by the DAICO contract. ); stopped = true; }","title":"freezeTransfer()"},{"location":"tkb/#unfreezetransfer","text":"Solo el contrato de la DAICO puede llamar a esta funci\u00f3n. Al llamar, stopped se pone en false, lo que hace que se descongelen las transferencias. function freezeTransfer() public { require(msg.sender == DAICOaddress, Must be called by the DAICO contract. ); stopped = false; }","title":"unfreezeTransfer()"},{"location":"tkb/#totalsupply","text":"Devuelve el total de tokens que hay. (Devuelve el totalSupply_ ) function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen.","title":"totalSupply()"},{"location":"tkb/#transfer","text":"Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance, restando la cantidad que tiene en stake . Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(!stopped, Transfers are paused. ); require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender].sub(stake[msg.sender].tokensStaked), Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir.","title":"transfer()"},{"location":"tkb/#balanceof","text":"Devuelve la cantidad de tokens que tiene _owner , restando la cantidad que tiene en stake . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner].sub(stake[_owner].tokensStaked); } Argumentos _owner address Direcci\u00f3n de quien devolver el balance.","title":"balanceOf()"},{"location":"tkb/#transferfrom","text":"Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance, restando la cantidad que tiene en stake y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(!stopped, Transfers are paused. ); require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from].sub(stake[msg.sender].tokensStaked), Insufficient balance ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"transferFrom()"},{"location":"tkb/#approve","text":"El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { require(_value != 0, Value must be more than 0. ); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"approve()"},{"location":"tkb/#allowance","text":"Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida.","title":"allowance()"},{"location":"tkb/#increaseapproval","text":"Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"increaseApproval()"},{"location":"tkb/#decreaseapproval","text":"Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"decreaseApproval()"},{"location":"tkb/#burn","text":"Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB. Comprueba que _amount no es 0 y que el msg.sender tiene suficiente balance. Despu\u00e9s calcula y asigna el % correspondiente al TKB y despu\u00e9s resta el _amount al msg.sender y resta de totalSupply_ el restante del _amount sin la cantidad enviada al TKB. function burn( uint256 _amount ) public onlyOwner returns (bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender], Insufficient balance. ); address _who = msg.sender; uint256 _amountForTKB = _amount.mul(150).div(10000); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); uint256 _amountWithoutFee = _amount.sub(_amountForTKB); balances[_who] = balances[_who].sub(_amountWithoutFee); totalSupply_ = totalSupply_.sub(_amountWithoutFee); emit Burn(_who, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"burn()"},{"location":"tkb/#mint","text":"Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB y se quitar\u00e1 un Y% correspondiente a la comisi\u00f3n de la tienda que cre\u00f3 el tiket. Comprueba que _amount no es 0, que _to no sea 0x000... y que _fee es mayor que 0 y menor que 500. Despu\u00e9s, calcula y quita la cantidad que se queda el CashNode y calcula la cantidad que se va al TKB y se lo asigna. Una vez ya se han sacado todas las comisiones, se aumenta el totalSupply_ y se le asignan los tokens restantes de _amount . function mint( address _to, uint256 _amount, uint256 _fee ) public onlyOwner returns (bool) { require(_amount 0, Amount must be more than 0 ); require(_to != address(0), You can't send tokens to this address ); require(_fee 0, Fees must be more than 0 ); require(_fee 500, Fees must be lower than 5%-500 units ); uint256 _amountCashNodeFee = _amount.mul(_fee).div(10000); uint256 _amountWithoutFee = _amount.sub(_amountCashNodeFee); totalSupply_ = totalSupply_.add(_amount); uint256 _amountForTKB = _amount.mul(150).div(10000); _amountWithoutFee = _amount.sub(_amountForTKB); balances[_to] = balances[_to].add(_amountWithoutFee); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); emit Mint(_to, _amountWithoutFee); emit TKBfee(_amountForTKB); emit Transfer(address(0), _to, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens a crear. _fee uint256 Cantidad de tokens que se queda el CashNode. _to address Direcci\u00f3n a la que enviar los tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"mint()"},{"location":"vesting/","text":"Vesting En este contrato se asignar\u00e1n a cada direcci\u00f3n las cantidades de tokens TKB y fecha de retirada que se hayan pactado previamente. Este contrato est\u00e1 destinado a guardar y congelar los tokens destinados al equipo, advisors, private sale, etc. La introducci\u00f3n de direcciones solo puede hacerse desde la direcci\u00f3n de owner , pero solo las direcciones apuntadas podr\u00e1n retirar fondos una vez se haya pasado el tiempo necesario Variables amountWithdrawn uint256 public constant TKBabi TKB public categories Category[] public Structs Cada Category representa los diferentes tipos de grupos que recibir\u00e1n tokens. struct Category { string name; uint256 amount; uint256 filledAmount; uint256 withdrawDate; mapping(address = uint) participantAmount; } Mappings Guarda el index de la Category a la que est\u00e1 asignado. mapping(address = uint) userCategory; Guarda las direcciones que ya han retirado su tokens. mapping(address = bool) alreadyWithdrawn; Funciones constructor() En el momento de la creaci\u00f3n del contrato, se generar\u00e1n las Category que se especifiquen. constructor(address _owner) public { categories.push(Category( Private sale , 50000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Pre sale , 100000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Team , 200000000*1000000000000000000, 0, block.timestamp.add(48 weeks))); categories.push(Category( Advisors , 30000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Partnerships , 30000000*1000000000000000000, 0, block.timestamp.add(12 weeks))); } addAddress() A\u00f1ade una direcci\u00f3n a la Category que se indique en _index y se le asigna la cantidad especificada en _amount . Primero se comprueba que la direcci\u00f3n no sea 0x000..., que el _index especificado es valido y si el _amount a\u00f1adido al total de la categor\u00eda, no pasa el limite de dicha Category . Despues se incrementa el filledAmount de la Category indicada y se le asigna el _amount en el mapping participantAmount . function addAddress( address _who, uint256 _amount, uint256 _index ) public onlyOwner { require(_who != address(0), Address can't be 0x0000... ); require(_index = 0 _index categories.length.sub(1), Index has to be valid ); require(_amount != 0, Amount must be more than 0 ); require(_amount.add(categories[_index].filledAmount) categories[_index].amount, Amount exceeds the limit. ); categories[_index].filledAmount = categories[_index].filledAmount.add(_amount); categories[_index].participantAmount[_who] = categories[_index].participantAmount[_who].add(_amount); userCategory[_who] = _index; } Argumentos _who string Direcci\u00f3n que se va a a\u00f1adir. _amount uint256 Cantidad a a\u00f1adir. _index uint256 \u00cdndice de la categor\u00eda. withdraw() Primero se comprueba que la direcci\u00f3n puede sacar ya los fondos, si ya ha retirado los fondos y si tiene alg\u00fan token que poder retirar. Despues, se le asigna que ya ha retirado los tokens, se incrementa amountWithdrawn y finalmente se le transfieren los tokens TKB . function withdraw() public { address _who = msg.sender; require(categories[userCategory[_who]].withdrawDate = block.timestamp, You can't withdraw yet. ); require(!alreadyWithdrawn[_who], Already withdrawn. ); uint256 _amount = categories[userCategory[_who]].participantAmount[_who]; require(_amount != 0, You don't have any amount to withdraw ); alreadyWithdrawn[_who] = true; amountWithdrawn = amountWithdrawn.add(_amount); TKBabi.transfer(_who, _amount); } Argumentos _who string Direcci\u00f3n que se va a retirar los fondos. getUserBalance() Devuelve la cantidad de tokens que tiene asignado _who . function getUserBalance( address _who ) public view returns (uint) { return categories[userCategory[_who]].participantAmount[_who]; } Argumentos _who string Direcci\u00f3n de la cual devolver el balance. Devuelve uint256 Balance del usuario.","title":"Vesting"},{"location":"vesting/#vesting","text":"En este contrato se asignar\u00e1n a cada direcci\u00f3n las cantidades de tokens TKB y fecha de retirada que se hayan pactado previamente. Este contrato est\u00e1 destinado a guardar y congelar los tokens destinados al equipo, advisors, private sale, etc. La introducci\u00f3n de direcciones solo puede hacerse desde la direcci\u00f3n de owner , pero solo las direcciones apuntadas podr\u00e1n retirar fondos una vez se haya pasado el tiempo necesario","title":"Vesting"},{"location":"vesting/#variables","text":"amountWithdrawn uint256 public constant TKBabi TKB public categories Category[] public","title":"Variables"},{"location":"vesting/#structs","text":"Cada Category representa los diferentes tipos de grupos que recibir\u00e1n tokens. struct Category { string name; uint256 amount; uint256 filledAmount; uint256 withdrawDate; mapping(address = uint) participantAmount; }","title":"Structs"},{"location":"vesting/#mappings","text":"Guarda el index de la Category a la que est\u00e1 asignado. mapping(address = uint) userCategory; Guarda las direcciones que ya han retirado su tokens. mapping(address = bool) alreadyWithdrawn;","title":"Mappings"},{"location":"vesting/#funciones","text":"","title":"Funciones"},{"location":"vesting/#constructor","text":"En el momento de la creaci\u00f3n del contrato, se generar\u00e1n las Category que se especifiquen. constructor(address _owner) public { categories.push(Category( Private sale , 50000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Pre sale , 100000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Team , 200000000*1000000000000000000, 0, block.timestamp.add(48 weeks))); categories.push(Category( Advisors , 30000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Partnerships , 30000000*1000000000000000000, 0, block.timestamp.add(12 weeks))); }","title":"constructor()"},{"location":"vesting/#addaddress","text":"A\u00f1ade una direcci\u00f3n a la Category que se indique en _index y se le asigna la cantidad especificada en _amount . Primero se comprueba que la direcci\u00f3n no sea 0x000..., que el _index especificado es valido y si el _amount a\u00f1adido al total de la categor\u00eda, no pasa el limite de dicha Category . Despues se incrementa el filledAmount de la Category indicada y se le asigna el _amount en el mapping participantAmount . function addAddress( address _who, uint256 _amount, uint256 _index ) public onlyOwner { require(_who != address(0), Address can't be 0x0000... ); require(_index = 0 _index categories.length.sub(1), Index has to be valid ); require(_amount != 0, Amount must be more than 0 ); require(_amount.add(categories[_index].filledAmount) categories[_index].amount, Amount exceeds the limit. ); categories[_index].filledAmount = categories[_index].filledAmount.add(_amount); categories[_index].participantAmount[_who] = categories[_index].participantAmount[_who].add(_amount); userCategory[_who] = _index; } Argumentos _who string Direcci\u00f3n que se va a a\u00f1adir. _amount uint256 Cantidad a a\u00f1adir. _index uint256 \u00cdndice de la categor\u00eda.","title":"addAddress()"},{"location":"vesting/#withdraw","text":"Primero se comprueba que la direcci\u00f3n puede sacar ya los fondos, si ya ha retirado los fondos y si tiene alg\u00fan token que poder retirar. Despues, se le asigna que ya ha retirado los tokens, se incrementa amountWithdrawn y finalmente se le transfieren los tokens TKB . function withdraw() public { address _who = msg.sender; require(categories[userCategory[_who]].withdrawDate = block.timestamp, You can't withdraw yet. ); require(!alreadyWithdrawn[_who], Already withdrawn. ); uint256 _amount = categories[userCategory[_who]].participantAmount[_who]; require(_amount != 0, You don't have any amount to withdraw ); alreadyWithdrawn[_who] = true; amountWithdrawn = amountWithdrawn.add(_amount); TKBabi.transfer(_who, _amount); } Argumentos _who string Direcci\u00f3n que se va a retirar los fondos.","title":"withdraw()"},{"location":"vesting/#getuserbalance","text":"Devuelve la cantidad de tokens que tiene asignado _who . function getUserBalance( address _who ) public view returns (uint) { return categories[userCategory[_who]].participantAmount[_who]; } Argumentos _who string Direcci\u00f3n de la cual devolver el balance. Devuelve uint256 Balance del usuario.","title":"getUserBalance()"}]}