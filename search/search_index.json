{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentaci\u00f3n de los tokens de Tikebit. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum tincidunt lorem justo, nec ornare dolor tincidunt id. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Proin sed orci et sapien consequat dignissim quis nec risus. Sed vel quam vitae erat maximus imperdiet a sed purus. Donec quis vulputate libero, a pellentesque velit. Suspendisse at purus vitae risus dapibus consequat nec nec arcu. Curabitur tristique, erat vitae ultrices hendrerit, justo ligula luctus augue, at dictum quam mauris a ligula. Ut risus lectus, tincidunt eget metus id, rutrum rutrum lacus. Suspendisse suscipit, justo ac eleifend vulputate, lacus quam sodales nulla, non tempor odio enim quis libero. Suspendisse sagittis tortor vitae dui posuere lobortis. Etiam bibendum eros vel nulla aliquet, et pellentesque quam porttitor. Quisque quis posuere felis. Pellentesque et ante cursus, semper ex eget, consequat odio. Nullam sit amet nunc lorem. Etiam aliquam molestie consequat.","title":"Documentaci\u00f3n de los tokens de Tikebit."},{"location":"#documentacion-de-los-tokens-de-tikebit","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum tincidunt lorem justo, nec ornare dolor tincidunt id. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Proin sed orci et sapien consequat dignissim quis nec risus. Sed vel quam vitae erat maximus imperdiet a sed purus. Donec quis vulputate libero, a pellentesque velit. Suspendisse at purus vitae risus dapibus consequat nec nec arcu. Curabitur tristique, erat vitae ultrices hendrerit, justo ligula luctus augue, at dictum quam mauris a ligula. Ut risus lectus, tincidunt eget metus id, rutrum rutrum lacus. Suspendisse suscipit, justo ac eleifend vulputate, lacus quam sodales nulla, non tempor odio enim quis libero. Suspendisse sagittis tortor vitae dui posuere lobortis. Etiam bibendum eros vel nulla aliquet, et pellentesque quam porttitor. Quisque quis posuere felis. Pellentesque et ante cursus, semper ex eget, consequat odio. Nullam sit amet nunc lorem. Etiam aliquam molestie consequat.","title":"Documentaci\u00f3n de los tokens de Tikebit."},{"location":"interface/","text":"Todos los c\u00f3digos utilizados provienen del repositorio de Open Zeppelin . ERC20Basic Interfaz para la creaci\u00f3n de tokens ERC20 con las funcionalidades b\u00e1sicas. contract ERC20Basic { function totalSupply() public view returns(uint256); function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); event Transfer(address indexed from, address indexed to, uint256 value); } ERC20 Interfaz complementaria de ERC20Basic que implementa funcionalidades extra para los tokens ERC20. contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns(uint256); function transferFrom(address from, address to, uint256 value) public returns(bool); function approve(address spender, uint256 value) public returns(bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } SafeMath Librer\u00eda utilizada para la implementaci\u00f3n de elementos de seguridad para las operaci\u00f3nes matem\u00e1ticas. Previene los overflows y lo undeflows. library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b = a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256 c) { c = a + b; assert(c = a); return c; } }","title":"Interfaces y librer\u00edas"},{"location":"interface/#erc20basic","text":"Interfaz para la creaci\u00f3n de tokens ERC20 con las funcionalidades b\u00e1sicas. contract ERC20Basic { function totalSupply() public view returns(uint256); function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); event Transfer(address indexed from, address indexed to, uint256 value); }","title":"ERC20Basic"},{"location":"interface/#erc20","text":"Interfaz complementaria de ERC20Basic que implementa funcionalidades extra para los tokens ERC20. contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns(uint256); function transferFrom(address from, address to, uint256 value) public returns(bool); function approve(address spender, uint256 value) public returns(bool); event Approval( address indexed owner, address indexed spender, uint256 value ); }","title":"ERC20"},{"location":"interface/#safemath","text":"Librer\u00eda utilizada para la implementaci\u00f3n de elementos de seguridad para las operaci\u00f3nes matem\u00e1ticas. Previene los overflows y lo undeflows. library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b = a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256 c) { c = a + b; assert(c = a); return c; } }","title":"SafeMath"},{"location":"ownable/","text":"En este caso, es el c\u00f3digo original de Open Zeppelin con varias funciones enfocadas a crear un super usuario que lo \u00fanico que puede hacer es retirar los permisos a la cuenta de owner . Variables owner address public superUser address public Eventos event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); event SuperUserTransferred( address indexed previousSu, address indexed newSu ); Modificadores onlyOwner() Solo la direcci\u00f3n que tenga el rol de owner puede llamar a la funci\u00f3n. modifier onlyOwner() { require(msg.sender == owner, You are not the owner. ); _; } onlySu() Solo la direcci\u00f3n que tenga el rol de superUser puede llamar a la funci\u00f3n. modifier onlySu() { require(msg.sender == superUser, You are not the super user. ); _; } Funciones constructor() En el momento de la creaci\u00f3n del contrato, se asigna el rol de owner y super usuario a la direcci\u00f3n que haya desplegado el contrato. constructor() public { owner = msg.sender; superUser = msg.sender; } transferSuperUser() El poseedor de los permisos superUsuario transfiere sus permisos a una nueva direcci\u00f3n. function transferSuperUser(address _newSu) public onlySu { require(_newSu != address(0), Adress can't be 0x0000... ); emit SuperUserTransferred(superUser, _newSu); superUser = _newSu; } Argumentos _newSu address Direcci\u00f3n del nuevo super usuario. renounceOwnership() El owner asigna sus permisos a la cuenta 0x000... dejando de ser el owner. function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } transferOwnership() El poseedor de los permisos superUsuario cambia los permisos de owner a la direcci\u00f3n proporcionada. function transferOwnership(address _newOwner) public onlySu { require(_newOwner != address(0), Adress can't be 0x0000... ); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } Argumentos _newOwner address Direcci\u00f3n del nuevo owner.","title":"Ownable"},{"location":"ownable/#variables","text":"owner address public superUser address public","title":"Variables"},{"location":"ownable/#eventos","text":"event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); event SuperUserTransferred( address indexed previousSu, address indexed newSu );","title":"Eventos"},{"location":"ownable/#modificadores","text":"","title":"Modificadores"},{"location":"ownable/#onlyowner","text":"Solo la direcci\u00f3n que tenga el rol de owner puede llamar a la funci\u00f3n. modifier onlyOwner() { require(msg.sender == owner, You are not the owner. ); _; }","title":"onlyOwner()"},{"location":"ownable/#onlysu","text":"Solo la direcci\u00f3n que tenga el rol de superUser puede llamar a la funci\u00f3n. modifier onlySu() { require(msg.sender == superUser, You are not the super user. ); _; }","title":"onlySu()"},{"location":"ownable/#funciones","text":"","title":"Funciones"},{"location":"ownable/#constructor","text":"En el momento de la creaci\u00f3n del contrato, se asigna el rol de owner y super usuario a la direcci\u00f3n que haya desplegado el contrato. constructor() public { owner = msg.sender; superUser = msg.sender; }","title":"constructor()"},{"location":"ownable/#transfersuperuser","text":"El poseedor de los permisos superUsuario transfiere sus permisos a una nueva direcci\u00f3n. function transferSuperUser(address _newSu) public onlySu { require(_newSu != address(0), Adress can't be 0x0000... ); emit SuperUserTransferred(superUser, _newSu); superUser = _newSu; } Argumentos _newSu address Direcci\u00f3n del nuevo super usuario.","title":"transferSuperUser()"},{"location":"ownable/#renounceownership","text":"El owner asigna sus permisos a la cuenta 0x000... dejando de ser el owner. function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); }","title":"renounceOwnership()"},{"location":"ownable/#transferownership","text":"El poseedor de los permisos superUsuario cambia los permisos de owner a la direcci\u00f3n proporcionada. function transferOwnership(address _newOwner) public onlySu { require(_newOwner != address(0), Adress can't be 0x0000... ); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } Argumentos _newOwner address Direcci\u00f3n del nuevo owner.","title":"transferOwnership()"},{"location":"teur/","text":"TEUR - Tikebit Euro La funcionalidad del TEUR es sencilla, ya que es un token ERC20 con todas las funcionalidades de las interfaces ERC20Basic y ERC20, adem\u00e1s de incluir mint y burn . Variables name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal TKBabi TKB public Mappings El mapping de \"balances\" es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de \"allowed\" guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed; Eventos event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event TKBfee(uint256 amount); Funciones constructor() En el momento de la creaci\u00f3n del contrato, al ser desplegado por el smart contract TKB, teniendo la ABI ya, vinculamos el msg.sender al ABI y tambi\u00e9n le transfiere los permisos a la direcci\u00f3n de _owner . constructor(address _owner) public { TKBabi = TKB(msg.sender); Ownable.transferOwnership(_owner); Ownable.transferSuperUser(_owner); } Argumentos owner address Direcci\u00f3n del nuevo owner y superUser . totalSupply() El poseedor de los permisos superUsuario transfiere sus permisos a una nueva direcci\u00f3n. function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen. transfer() Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance. Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender], Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir. balanceOf() Devuelve la cantidad de tokens que tiene _owner . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner]; } Argumentos _owner address Direcci\u00f3n de quien devolver el balance. transferFrom() Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from], Insufficient balance. ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. approve() El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. allowance() Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida. increaseApproval() Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. increaseApproval() Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. burn() Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB. Comprueba que _amount no es 0 y que el msg.sender tiene suficiente balance. Despu\u00e9s calcula y asigna el % correspondiente al TKB y despu\u00e9s resta el _amount al msg.sender y resta de totalSupply_ el restante del _amount sin la cantidad enviada al TKB. function burn( uint256 _amount ) public onlyOwner returns (bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender], Insufficient balance. ); address _who = msg.sender; uint256 _amountForTKB = _amount.mul(150).div(10000); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); uint256 _amountWithoutFee = _amount.sub(_amountForTKB); balances[_who] = balances[_who].sub(_amountWithoutFee); totalSupply_ = totalSupply_.sub(_amountWithoutFee); emit Burn(_who, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. mint() Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB y se quitar\u00e1 un Y% correspondiente a la comisi\u00f3n de la tienda que cre\u00f3 el tiket. Comprueba que _amount no es 0, que _to no sea 0x000... y que _fee es mayor que 0 y menor que 500. Despu\u00e9s, calcula y quita la cantidad que se queda el CashNode y calcula la cantidad que se va al TKB y se lo asigna. Una vez ya se han sacado todas las comisiones, se aumenta el totalSupply_ y se le asignan los tokens restantes de _amount . function mint( address _to, uint256 _amount, uint256 _fee ) public onlyOwner returns (bool) { require(_amount 0, Amount must be more than 0 ); require(_to != address(0), You can't send tokens to this address ); require(_fee 0, Fees must be more than 0 ); require(_fee 500, Fees must be lower than 5%-500 units ); uint256 _amountCashNodeFee = _amount.mul(_fee).div(10000); uint256 _amountWithoutFee = _amount.sub(_amountCashNodeFee); totalSupply_ = totalSupply_.add(_amount); uint256 _amountForTKB = _amount.mul(150).div(10000); _amountWithoutFee = _amount.sub(_amountForTKB); balances[_to] = balances[_to].add(_amountWithoutFee); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); emit Mint(_to, _amountWithoutFee); emit TKBfee(_amountForTKB); emit Transfer(address(0), _to, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens a crear. _fee uint256 Cantidad de tokens que se queda el CashNode. _to address Direcci\u00f3n a la que enviar los tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"TEUR"},{"location":"teur/#teur-tikebit-euro","text":"La funcionalidad del TEUR es sencilla, ya que es un token ERC20 con todas las funcionalidades de las interfaces ERC20Basic y ERC20, adem\u00e1s de incluir mint y burn .","title":"TEUR - Tikebit Euro"},{"location":"teur/#variables","text":"name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal TKBabi TKB public","title":"Variables"},{"location":"teur/#mappings","text":"El mapping de \"balances\" es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de \"allowed\" guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed;","title":"Mappings"},{"location":"teur/#eventos","text":"event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event TKBfee(uint256 amount);","title":"Eventos"},{"location":"teur/#funciones","text":"","title":"Funciones"},{"location":"teur/#constructor","text":"En el momento de la creaci\u00f3n del contrato, al ser desplegado por el smart contract TKB, teniendo la ABI ya, vinculamos el msg.sender al ABI y tambi\u00e9n le transfiere los permisos a la direcci\u00f3n de _owner . constructor(address _owner) public { TKBabi = TKB(msg.sender); Ownable.transferOwnership(_owner); Ownable.transferSuperUser(_owner); } Argumentos owner address Direcci\u00f3n del nuevo owner y superUser .","title":"constructor()"},{"location":"teur/#totalsupply","text":"El poseedor de los permisos superUsuario transfiere sus permisos a una nueva direcci\u00f3n. function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen.","title":"totalSupply()"},{"location":"teur/#transfer","text":"Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance. Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender], Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir.","title":"transfer()"},{"location":"teur/#balanceof","text":"Devuelve la cantidad de tokens que tiene _owner . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner]; } Argumentos _owner address Direcci\u00f3n de quien devolver el balance.","title":"balanceOf()"},{"location":"teur/#transferfrom","text":"Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from], Insufficient balance. ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"transferFrom()"},{"location":"teur/#approve","text":"El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"approve()"},{"location":"teur/#allowance","text":"Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida.","title":"allowance()"},{"location":"teur/#increaseapproval","text":"Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"increaseApproval()"},{"location":"teur/#increaseapproval_1","text":"Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"increaseApproval()"},{"location":"teur/#burn","text":"Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB. Comprueba que _amount no es 0 y que el msg.sender tiene suficiente balance. Despu\u00e9s calcula y asigna el % correspondiente al TKB y despu\u00e9s resta el _amount al msg.sender y resta de totalSupply_ el restante del _amount sin la cantidad enviada al TKB. function burn( uint256 _amount ) public onlyOwner returns (bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender], Insufficient balance. ); address _who = msg.sender; uint256 _amountForTKB = _amount.mul(150).div(10000); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); uint256 _amountWithoutFee = _amount.sub(_amountForTKB); balances[_who] = balances[_who].sub(_amountWithoutFee); totalSupply_ = totalSupply_.sub(_amountWithoutFee); emit Burn(_who, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"burn()"},{"location":"teur/#mint","text":"Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB y se quitar\u00e1 un Y% correspondiente a la comisi\u00f3n de la tienda que cre\u00f3 el tiket. Comprueba que _amount no es 0, que _to no sea 0x000... y que _fee es mayor que 0 y menor que 500. Despu\u00e9s, calcula y quita la cantidad que se queda el CashNode y calcula la cantidad que se va al TKB y se lo asigna. Una vez ya se han sacado todas las comisiones, se aumenta el totalSupply_ y se le asignan los tokens restantes de _amount . function mint( address _to, uint256 _amount, uint256 _fee ) public onlyOwner returns (bool) { require(_amount 0, Amount must be more than 0 ); require(_to != address(0), You can't send tokens to this address ); require(_fee 0, Fees must be more than 0 ); require(_fee 500, Fees must be lower than 5%-500 units ); uint256 _amountCashNodeFee = _amount.mul(_fee).div(10000); uint256 _amountWithoutFee = _amount.sub(_amountCashNodeFee); totalSupply_ = totalSupply_.add(_amount); uint256 _amountForTKB = _amount.mul(150).div(10000); _amountWithoutFee = _amount.sub(_amountForTKB); balances[_to] = balances[_to].add(_amountWithoutFee); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); emit Mint(_to, _amountWithoutFee); emit TKBfee(_amountForTKB); emit Transfer(address(0), _to, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens a crear. _fee uint256 Cantidad de tokens que se queda el CashNode. _to address Direcci\u00f3n a la que enviar los tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"mint()"}]}