{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentaci\u00f3n de los tokens Tikebit. Aqu\u00ed podr\u00e1s encontrar la documentaci\u00f3n de todos los smart contracts que forman la red de tokens Tikebit. Tambi\u00e9n puedes encontrar los contratos subidos en las diferentes redes: Mainnet: 0x0000000000000000000000000000000000000000 Rinkeby: 0x0000000000000000000000000000000000000000 Kovan: 0x0000000000000000000000000000000000000000","title":"Documentaci\u00f3n de los tokens Tikebit."},{"location":"#documentacion-de-los-tokens-tikebit","text":"Aqu\u00ed podr\u00e1s encontrar la documentaci\u00f3n de todos los smart contracts que forman la red de tokens Tikebit. Tambi\u00e9n puedes encontrar los contratos subidos en las diferentes redes: Mainnet: 0x0000000000000000000000000000000000000000 Rinkeby: 0x0000000000000000000000000000000000000000 Kovan: 0x0000000000000000000000000000000000000000","title":"Documentaci\u00f3n de los tokens Tikebit."},{"location":"daico/","text":"DAICO - ICO + DAO El TKB implementa las funcionalidades de ERC20Basic y ERC20 . La finalidad de este token es permitir el reparto de las fee que se generan en el TEUR . Para conseguir esto, se podr\u00e1n generar stakes , que contienen stakeUnits las cuales representan las unidades proporcionales que recibir\u00e1s respecto a la feePool . Tambi\u00e9n se implementa un sistema de fechas donde est\u00e1 todo controlado para que se restrinja cada acci\u00f3n a determinada fecha. Los tokens usados en los stakes se restar\u00e1n del balance de la direcci\u00f3n en funciones como transfer() , transferFrom() y las que requieran saber del balance de tokens de una direcci\u00f3n. Las transferencias estar\u00e1n congeladas hasta que se termine la ICO, la variable que controla esto es stopped . Es posible que una vez terminada la ICO se vuelva a para el contrato, pero solo en el caso de que se pida un refund de la DAICO, permitiendo as\u00ed ir al contrato de la DAICO a retirar ETH a raz\u00f3n de los tokens TKB que tengas. Esta variable no es posible cambiarla de forma manual, se descongelar\u00e1 una vez termine la ICO de forma autom\u00e1tica y al pedir un refund mediante la DAO. Variables wallet address public icoDate uint256 public hardCap uint256 public softCap uint256 public weiRaised uint256 public withdrawDate uint256 public dateUntillNextRequest uint256 public voteRestrictionDate uint256 public tokensSold uint256 public refundVotes uint256 public refundDAO bool public refundICO bool public icoFinalized bool public TKBabi TKB public requests Request[] public Structs Las peticiones de la DAO siguen la estructura Request , la cual guarda los datos b\u00e1sicos de cada petici\u00f3n y tambi\u00e9n un mapping donde se apuntar\u00e1 las direcciones que ya han votado. struct Request { string description; uint256 value; uint256 declineCount; uint256 dateFinalize; address recipient; bool complete; mapping(address = bool) decliners; } Cuando una direcci\u00f3n participa en la ICO, se le a\u00f1ade al mapping contributors y se le asigna la estructura Contributor para guardar futuros datos struct Contributor { uint256 weiContributed; bool votedToRefund; bool gotRefundICO; bool gotRefundDAO; } Mappings Aqu\u00ed se guardan los datos de las direcciones que participan en la ICO. Tambi\u00e9n se usa en un futuro si se realiza un refundDAO , donde guardar\u00e1 si la direcci\u00f3n ha recibido el refund, sin importar si particip\u00f3 en la ICO. mapping(address = Contributor) public contributors; Funciones constructor() Al desplegar el contrato, se asignar\u00e1n los valores de la fecha, hard cap, soft cap, etc. Este apartado no est\u00e1 terminado, ya que falta poner los valores y fechas reales constructor( address _owner, address _token, uint256 _date ) public { require(_owner != address(0), Adress can't be 0x0000... ); require(_token != address(0), Adress can't be 0x0000... ); Ownable.transferOwnership(_owner); wallet = _owner; TKBabi = TKB(_token); icoDate = _date; voteRestrictionDate = icoDate.add(17 weeks); dateUntillNextRequest = _date; hardCap = 500000000000000000000000000; softCap = 200000000000000000000000000; } fallback() Por temas de estructura, la funci\u00f3n fallback solo llama a la funci\u00f3n buyTokens . function() external payable { buyTokens(msg.sender); } buyTokens() Primero se comprueba que no haya terminado la ICO. Despues se llama a _preValidatePurchase para realizar m\u00e1s comprovaciones. Posteriormente se calcula la cantidad de tokens a recibir usando _gerTokenAmount . Si los tokens a recibir no superan el hardCap , se procede a llamar a _processPurchase para realizar la compra. function buyTokens( address _user ) private { require(block.timestamp = icoDate, Ico ended, you can't buy tokens. ); uint256 weiAmount = msg.value; _preValidatePurchase(_user, weiAmount); uint256 _tokens = _getTokenAmount(weiAmount); require (tokensSold.add(_tokens) = hardCap, The hardCap is reached. ); weiRaised = weiRaised.add(weiAmount); tokensSold = tokensSold.add(_tokens); _processPurchase(_user, weiAmount, _tokens); } Argumentos _user address Direcci\u00f3n a recibir los tokens. _preValidatePurchase() Comprueba que el usuario no es 0x000... y que la cantidad de _weiAmount no es 0. function _preValidatePurchase( address _user, uint256 _weiAmount ) internal pure { require(_user != address(0), Adress can't be 0x0000... ); require(_weiAmount != 0, Amount must be more than 0 ); } Argumentos _weiAmount uint256 Cantidad de wei enviada. _user address Direcci\u00f3n a la cual reducir el array. _getTokenAmount() Al llamar con la cantidad de wei enviada, se calcula si se cumplen las condiciones del if . Lo que se comprueba es la cantidad de tokens ya comprados y se realizan descuentos dependiendo de que l\u00edmite que se haya superado. function _getTokenAmount( uint256 _weiAmount ) internal view returns (uint256) { if (weiRaised 400 ether weiRaised.add(_weiAmount) = 400 ether) { return _weiAmount.mul(13500); } else if (weiRaised 2000 ether weiRaised.add(_weiAmount) = 2000 ether) { return _weiAmount.mul(13000); } else if (weiRaised 4400 ether weiRaised.add(_weiAmount) = 4400 ether) { return _weiAmount.mul(12750); } else { return _weiAmount.mul(12500); } } Argumentos _weiAmount uint256 Cantidad de wei enviada. Devuelve uint256 Cantidad de tokens. _processPurchase() Se asigna _weiAmount a la direcci\u00f3n de _user en el mapping contributors y se llama al TKB para procesar la compra. function _processPurchase( address _user, uint256 _weiAmount, uint256 _tokenAmount ) internal { contributors[_user].weiContributed = contributors[_user].weiContributed.add(_weiAmount); TKBabi.transfer(_user, _tokenAmount); } Argumentos _user address Usuario que recibe los tokens. _weiAmount uint256 Cantidad de wei enviada. _tokenAmount uint256 Cantidad de tokens a enviar. finalizeICO() Una vez pase la fecha icoDate , se tiene que llamar a esta funci\u00f3n para terminar la ICO. Si se ha superado el softCap , se descongela el TKB usando unfreezeTransfer() y se queman el sobrante de tokens. Si no se supera el softCap , se queman los tokens sobrantes y se activa refundICO . function finalizeICO() public { require(icoDate = block.timestamp, It's not possible to close the ICO yet. ); require(!icoFinalized, ICO already finalized ); icoFinalized = true; uint256 tokenAmount = 500000000; // ------------ if (tokensSold softCap) { refundICO = true; TKBabi.burn(tokenAmount.sub(tokensSold)); } else if (tokensSold = softCap){ TKBabi.unfreezeTransfer(); // ------------ TKBabi.burn(tokenAmount.sub(tokensSold)); } } refundICO() En el caso de que est\u00e9 activado refundICO , se activa esta funci\u00f3n. Al llamar se comprueba que la direcci\u00f3n ha participado en la ICO mirando el mapping de contributors . Si se ha contribuido y no ha recibido refund ya, se transfiere el wei que se indique en weiContributed . function refundICO() public { require(refundICO, Refund isn't active ); require(msg.sender != address(0), Adress can't be 0x0000... ); require(contributors[msg.sender].weiContributed != 0, You didn't contribute to the ICO ); require(!contributors[msg.sender].gotRefundICO, Already withdrawn the refund. ); address _user = msg.sender; contributors[_user].gotRefundICO = true; _user.transfer(contributors[_user].weiContributed); } createRequest() Solo el owner puede crear las peticiones. Se comprueba que haya terminado la ICO y que no est\u00e1 activado el refund. Luego se comprueba el sistema de fechas donde hay una fecha a partir de la cual se pueden hacer peticiones y a partir de ah\u00ed, se comprueba que el dateUntillNextRequest es menor que la fecha actual. Tambi\u00e9n hay un l\u00edmite de 800ETH por petici\u00f3n. Una vez es todo valido, se a\u00f1aden 8 weeks a dateUntillNextRequest y se crea la petici\u00f3n y se introduce en el array requests . S\u00f3lo se podr\u00e1 votar en contra de la petici\u00f3n en los 3 d\u00edas siguientes a la creaci\u00f3n de la petici\u00f3n. function createRequest( string _description, uint256 _value, address _recipient ) public onlyOwner { require(icoFinalized, ICO must end before calling this function. ); require(!refundICO, It's not possible to create request if the refund is active. ); require(voteRestrictionDate block.timestamp, It's not time yet to create request. ); require(dateUntillNextRequest = block.timestamp, It's not possible to create a request. ); require(_value = 800 ether, The amount exceeds the limit. ); dateUntillNextRequest = block.timestamp.add(8 weeks); requests.push(Request({ description: _description, value: _value, dateFinalize: block.timestamp.add(3 days), recipient: _recipient, complete: false, declineCount: 0 })); } Argumentos _description string Descripci\u00f3n de la petici\u00f3n. _value uint256 Cantidad a retirar si se aprueba la petici\u00f3n. _recipient address Direcci\u00f3n a la que enviar los fondos. declineRequest() Para que no se cumpla una petici\u00f3n, las direcciones que tengan stakeUnits en el TKB , tienen que llamar a esta funci\u00f3n para votar en contra. Se comprueba que la petici\u00f3n indicada exista, que a\u00fan se pueda votar en dicha petici\u00f3n y que la direcci\u00f3n tenga alg\u00fan stakeUnit . No se puede votar si esa direcci\u00f3n ha pedido el refund de la DAO o si ya has votado en dicha petici\u00f3n. Si todo se cumple, se a\u00f1ade la cantidad de stakeUnit que tenga la direcci\u00f3n al contador de la petici\u00f3n declineCount . function declineRequest( uint256 _index ) public { require(_index requests.length, This request doesn't exist. ); Request storage request = requests[_index]; require(request.dateFinalize block.timestamp, The time is over to vote in this request. ); uint256 stakeUnits = TKBabi.getStakeUnits(msg.sender); require(stakeUnits != 0, You need a node to vote. ); require(!contributors[msg.sender].votedToRefund, You can't vote if you want to get a refund. ); require(!request.decliners[msg.sender], Already voted in this request. ); request.decliners[msg.sender] = true; request.declineCount = request.declineCount.add(stakeUnits); } Argumentos uint256 Indice de la petici\u00f3n a rechazar. finalizeRequest() Cuando pasan los 3 d\u00edas, el owner llama a esta funci\u00f3n. Primero se marca como complete y si se ha rechazado la petici\u00f3n, se reduce dateUntillNextRequest a 1 weeks . Si se aprueba, se envian los fondos de value . function finalizeRequest( uint256 _index ) public onlyOwner { require(_index requests.length, This request doesn't exist. ); Request storage request = requests[_index]; require(request.dateFinalize = block.timestamp, It's not possible to finalize this request. ); require(!request.complete, This request is already finalized. ); uint256 amountStakeUnits = TKBabi.amountStakeUnits(); request.complete = true; if(request.declineCount = amountStakeUnits / 2 amountStakeUnits / 2 500) { request.recipient.transfer(request.value); } else { dateUntillNextRequest = block.timestamp.add(1 weeks); } } Argumentos uint256 Indice de la petici\u00f3n. askForRefund() Las direcciones que tengan stakeUnit en el TKB , pueden llamar para que se haga un refund de la DAO, devolviendo los fondos que queden en la DAO. Se comprueba que ha terminado la ICO, que no se haya hecho un refundICO y si se puede pedir el refund ya. Despu\u00e9s se comprueba si tiene stakeUnits y si ya ha votado. Despues, se a\u00f1ade la cantidad de stakeUnits a refundVotes y a amountVotedRefund y se comprueba si hay votos suficientes para realizar el refund (+50%). Si se supera, SE ACTIVA refundDAO y se congelan las transferencias en el TKB . function askForRefund() public { require(icoFinalized, The ICO must end before you ask for a refund. ); require(!refundICO, If refundICO is active, you can't ask for a refund. ); require(voteRestrictionDate = block.timestamp, It's not time yet to ask for a refund. ); uint256 stakeUnits = TKBabi.getStakeUnits(msg.sender); require(stakeUnits != 0, You need 1 or more stake units to vote. ); require(!contributors[msg.sender].votedToRefund, You already voted to get a refund. If you want to undo this, call undoAskForRefund() ); contributors[msg.sender].votedToRefund = true; contributors[msg.sender].amountVotedRefund = stakeUnits; refundVotes = refundVotes.add(stakeUnits); uint256 amountStakeUnits = TKBabi.amountStakeUnits(); if (refundVotes amountStakeUnits/2 amountStakeUnits / 2 500) { // -------------------------- refundDAO = true; TKBabi.freezeTransfer(); } } undoAskForRefund() Se comprueba que la ICO ha terminado, que el refundICO no est\u00e1 activo y que la direcci\u00f3n haya pedido el refund previamente. Luego se saca los votos que realiz\u00f3 la direcci\u00f3n cogiendo amountVotedRefund . Se comprueba que no es 0 y se pone a false votedToRefund y se restan los votos de refundVotes . function undoAskForRefund() public { require(icoFinalized, The ICO must end before you ask for a refund. ); require(!refundICO, If refundICO is active, you can't ask for a refund. ); require(!contributors[msg.sender].votedToRefund, You didn't asked for a refund. ); uint256 stakeUnits = contributors[msg.sender].amountVotedRefund; require(stakeUnits != 0, You need 1 or more stake units to vote. ); contributors[msg.sender].votedToRefund = false; refundVotes = refundVotes.sub(stakeUnits); } withdrawRefundDAO() Si se ha activado refundDAO y la direcci\u00f3n no ha pedido un refund previamente, se marca como que va a recibir un refund, se consigue la cantidad de TKB que tiene y si tiene m\u00e1s de 0, se calcula proporcionalmente el wei que hay que mandarle. function withdrawRefundDAO() public { require(refundDAO, Refund must be active. ); require(!contributors[msg.sender].gotRefundDAO, You already got a refund. ); contributors[msg.sender].gotRefundDAO = true; uint256 TKBHold = TKBabi.balanceOf(msg.sender); require(TKBHold != 0, You need to have some TKB to get the refund. ); uint256 _amount = ((address(this).balance).div(tokensSold)).mul(TKBHold); msg.sender.transfer(_amount); }","title":"DAICO"},{"location":"daico/#daico-ico-dao","text":"El TKB implementa las funcionalidades de ERC20Basic y ERC20 . La finalidad de este token es permitir el reparto de las fee que se generan en el TEUR . Para conseguir esto, se podr\u00e1n generar stakes , que contienen stakeUnits las cuales representan las unidades proporcionales que recibir\u00e1s respecto a la feePool . Tambi\u00e9n se implementa un sistema de fechas donde est\u00e1 todo controlado para que se restrinja cada acci\u00f3n a determinada fecha. Los tokens usados en los stakes se restar\u00e1n del balance de la direcci\u00f3n en funciones como transfer() , transferFrom() y las que requieran saber del balance de tokens de una direcci\u00f3n. Las transferencias estar\u00e1n congeladas hasta que se termine la ICO, la variable que controla esto es stopped . Es posible que una vez terminada la ICO se vuelva a para el contrato, pero solo en el caso de que se pida un refund de la DAICO, permitiendo as\u00ed ir al contrato de la DAICO a retirar ETH a raz\u00f3n de los tokens TKB que tengas. Esta variable no es posible cambiarla de forma manual, se descongelar\u00e1 una vez termine la ICO de forma autom\u00e1tica y al pedir un refund mediante la DAO.","title":"DAICO - ICO + DAO"},{"location":"daico/#variables","text":"wallet address public icoDate uint256 public hardCap uint256 public softCap uint256 public weiRaised uint256 public withdrawDate uint256 public dateUntillNextRequest uint256 public voteRestrictionDate uint256 public tokensSold uint256 public refundVotes uint256 public refundDAO bool public refundICO bool public icoFinalized bool public TKBabi TKB public requests Request[] public","title":"Variables"},{"location":"daico/#structs","text":"Las peticiones de la DAO siguen la estructura Request , la cual guarda los datos b\u00e1sicos de cada petici\u00f3n y tambi\u00e9n un mapping donde se apuntar\u00e1 las direcciones que ya han votado. struct Request { string description; uint256 value; uint256 declineCount; uint256 dateFinalize; address recipient; bool complete; mapping(address = bool) decliners; } Cuando una direcci\u00f3n participa en la ICO, se le a\u00f1ade al mapping contributors y se le asigna la estructura Contributor para guardar futuros datos struct Contributor { uint256 weiContributed; bool votedToRefund; bool gotRefundICO; bool gotRefundDAO; }","title":"Structs"},{"location":"daico/#mappings","text":"Aqu\u00ed se guardan los datos de las direcciones que participan en la ICO. Tambi\u00e9n se usa en un futuro si se realiza un refundDAO , donde guardar\u00e1 si la direcci\u00f3n ha recibido el refund, sin importar si particip\u00f3 en la ICO. mapping(address = Contributor) public contributors;","title":"Mappings"},{"location":"daico/#funciones","text":"","title":"Funciones"},{"location":"daico/#constructor","text":"Al desplegar el contrato, se asignar\u00e1n los valores de la fecha, hard cap, soft cap, etc. Este apartado no est\u00e1 terminado, ya que falta poner los valores y fechas reales constructor( address _owner, address _token, uint256 _date ) public { require(_owner != address(0), Adress can't be 0x0000... ); require(_token != address(0), Adress can't be 0x0000... ); Ownable.transferOwnership(_owner); wallet = _owner; TKBabi = TKB(_token); icoDate = _date; voteRestrictionDate = icoDate.add(17 weeks); dateUntillNextRequest = _date; hardCap = 500000000000000000000000000; softCap = 200000000000000000000000000; }","title":"constructor()"},{"location":"daico/#fallback","text":"Por temas de estructura, la funci\u00f3n fallback solo llama a la funci\u00f3n buyTokens . function() external payable { buyTokens(msg.sender); }","title":"fallback()"},{"location":"daico/#buytokens","text":"Primero se comprueba que no haya terminado la ICO. Despues se llama a _preValidatePurchase para realizar m\u00e1s comprovaciones. Posteriormente se calcula la cantidad de tokens a recibir usando _gerTokenAmount . Si los tokens a recibir no superan el hardCap , se procede a llamar a _processPurchase para realizar la compra. function buyTokens( address _user ) private { require(block.timestamp = icoDate, Ico ended, you can't buy tokens. ); uint256 weiAmount = msg.value; _preValidatePurchase(_user, weiAmount); uint256 _tokens = _getTokenAmount(weiAmount); require (tokensSold.add(_tokens) = hardCap, The hardCap is reached. ); weiRaised = weiRaised.add(weiAmount); tokensSold = tokensSold.add(_tokens); _processPurchase(_user, weiAmount, _tokens); } Argumentos _user address Direcci\u00f3n a recibir los tokens.","title":"buyTokens()"},{"location":"daico/#_prevalidatepurchase","text":"Comprueba que el usuario no es 0x000... y que la cantidad de _weiAmount no es 0. function _preValidatePurchase( address _user, uint256 _weiAmount ) internal pure { require(_user != address(0), Adress can't be 0x0000... ); require(_weiAmount != 0, Amount must be more than 0 ); } Argumentos _weiAmount uint256 Cantidad de wei enviada. _user address Direcci\u00f3n a la cual reducir el array.","title":"_preValidatePurchase()"},{"location":"daico/#_gettokenamount","text":"Al llamar con la cantidad de wei enviada, se calcula si se cumplen las condiciones del if . Lo que se comprueba es la cantidad de tokens ya comprados y se realizan descuentos dependiendo de que l\u00edmite que se haya superado. function _getTokenAmount( uint256 _weiAmount ) internal view returns (uint256) { if (weiRaised 400 ether weiRaised.add(_weiAmount) = 400 ether) { return _weiAmount.mul(13500); } else if (weiRaised 2000 ether weiRaised.add(_weiAmount) = 2000 ether) { return _weiAmount.mul(13000); } else if (weiRaised 4400 ether weiRaised.add(_weiAmount) = 4400 ether) { return _weiAmount.mul(12750); } else { return _weiAmount.mul(12500); } } Argumentos _weiAmount uint256 Cantidad de wei enviada. Devuelve uint256 Cantidad de tokens.","title":"_getTokenAmount()"},{"location":"daico/#_processpurchase","text":"Se asigna _weiAmount a la direcci\u00f3n de _user en el mapping contributors y se llama al TKB para procesar la compra. function _processPurchase( address _user, uint256 _weiAmount, uint256 _tokenAmount ) internal { contributors[_user].weiContributed = contributors[_user].weiContributed.add(_weiAmount); TKBabi.transfer(_user, _tokenAmount); } Argumentos _user address Usuario que recibe los tokens. _weiAmount uint256 Cantidad de wei enviada. _tokenAmount uint256 Cantidad de tokens a enviar.","title":"_processPurchase()"},{"location":"daico/#finalizeico","text":"Una vez pase la fecha icoDate , se tiene que llamar a esta funci\u00f3n para terminar la ICO. Si se ha superado el softCap , se descongela el TKB usando unfreezeTransfer() y se queman el sobrante de tokens. Si no se supera el softCap , se queman los tokens sobrantes y se activa refundICO . function finalizeICO() public { require(icoDate = block.timestamp, It's not possible to close the ICO yet. ); require(!icoFinalized, ICO already finalized ); icoFinalized = true; uint256 tokenAmount = 500000000; // ------------ if (tokensSold softCap) { refundICO = true; TKBabi.burn(tokenAmount.sub(tokensSold)); } else if (tokensSold = softCap){ TKBabi.unfreezeTransfer(); // ------------ TKBabi.burn(tokenAmount.sub(tokensSold)); } }","title":"finalizeICO()"},{"location":"daico/#refundico","text":"En el caso de que est\u00e9 activado refundICO , se activa esta funci\u00f3n. Al llamar se comprueba que la direcci\u00f3n ha participado en la ICO mirando el mapping de contributors . Si se ha contribuido y no ha recibido refund ya, se transfiere el wei que se indique en weiContributed . function refundICO() public { require(refundICO, Refund isn't active ); require(msg.sender != address(0), Adress can't be 0x0000... ); require(contributors[msg.sender].weiContributed != 0, You didn't contribute to the ICO ); require(!contributors[msg.sender].gotRefundICO, Already withdrawn the refund. ); address _user = msg.sender; contributors[_user].gotRefundICO = true; _user.transfer(contributors[_user].weiContributed); }","title":"refundICO()"},{"location":"daico/#createrequest","text":"Solo el owner puede crear las peticiones. Se comprueba que haya terminado la ICO y que no est\u00e1 activado el refund. Luego se comprueba el sistema de fechas donde hay una fecha a partir de la cual se pueden hacer peticiones y a partir de ah\u00ed, se comprueba que el dateUntillNextRequest es menor que la fecha actual. Tambi\u00e9n hay un l\u00edmite de 800ETH por petici\u00f3n. Una vez es todo valido, se a\u00f1aden 8 weeks a dateUntillNextRequest y se crea la petici\u00f3n y se introduce en el array requests . S\u00f3lo se podr\u00e1 votar en contra de la petici\u00f3n en los 3 d\u00edas siguientes a la creaci\u00f3n de la petici\u00f3n. function createRequest( string _description, uint256 _value, address _recipient ) public onlyOwner { require(icoFinalized, ICO must end before calling this function. ); require(!refundICO, It's not possible to create request if the refund is active. ); require(voteRestrictionDate block.timestamp, It's not time yet to create request. ); require(dateUntillNextRequest = block.timestamp, It's not possible to create a request. ); require(_value = 800 ether, The amount exceeds the limit. ); dateUntillNextRequest = block.timestamp.add(8 weeks); requests.push(Request({ description: _description, value: _value, dateFinalize: block.timestamp.add(3 days), recipient: _recipient, complete: false, declineCount: 0 })); } Argumentos _description string Descripci\u00f3n de la petici\u00f3n. _value uint256 Cantidad a retirar si se aprueba la petici\u00f3n. _recipient address Direcci\u00f3n a la que enviar los fondos.","title":"createRequest()"},{"location":"daico/#declinerequest","text":"Para que no se cumpla una petici\u00f3n, las direcciones que tengan stakeUnits en el TKB , tienen que llamar a esta funci\u00f3n para votar en contra. Se comprueba que la petici\u00f3n indicada exista, que a\u00fan se pueda votar en dicha petici\u00f3n y que la direcci\u00f3n tenga alg\u00fan stakeUnit . No se puede votar si esa direcci\u00f3n ha pedido el refund de la DAO o si ya has votado en dicha petici\u00f3n. Si todo se cumple, se a\u00f1ade la cantidad de stakeUnit que tenga la direcci\u00f3n al contador de la petici\u00f3n declineCount . function declineRequest( uint256 _index ) public { require(_index requests.length, This request doesn't exist. ); Request storage request = requests[_index]; require(request.dateFinalize block.timestamp, The time is over to vote in this request. ); uint256 stakeUnits = TKBabi.getStakeUnits(msg.sender); require(stakeUnits != 0, You need a node to vote. ); require(!contributors[msg.sender].votedToRefund, You can't vote if you want to get a refund. ); require(!request.decliners[msg.sender], Already voted in this request. ); request.decliners[msg.sender] = true; request.declineCount = request.declineCount.add(stakeUnits); } Argumentos uint256 Indice de la petici\u00f3n a rechazar.","title":"declineRequest()"},{"location":"daico/#finalizerequest","text":"Cuando pasan los 3 d\u00edas, el owner llama a esta funci\u00f3n. Primero se marca como complete y si se ha rechazado la petici\u00f3n, se reduce dateUntillNextRequest a 1 weeks . Si se aprueba, se envian los fondos de value . function finalizeRequest( uint256 _index ) public onlyOwner { require(_index requests.length, This request doesn't exist. ); Request storage request = requests[_index]; require(request.dateFinalize = block.timestamp, It's not possible to finalize this request. ); require(!request.complete, This request is already finalized. ); uint256 amountStakeUnits = TKBabi.amountStakeUnits(); request.complete = true; if(request.declineCount = amountStakeUnits / 2 amountStakeUnits / 2 500) { request.recipient.transfer(request.value); } else { dateUntillNextRequest = block.timestamp.add(1 weeks); } } Argumentos uint256 Indice de la petici\u00f3n.","title":"finalizeRequest()"},{"location":"daico/#askforrefund","text":"Las direcciones que tengan stakeUnit en el TKB , pueden llamar para que se haga un refund de la DAO, devolviendo los fondos que queden en la DAO. Se comprueba que ha terminado la ICO, que no se haya hecho un refundICO y si se puede pedir el refund ya. Despu\u00e9s se comprueba si tiene stakeUnits y si ya ha votado. Despues, se a\u00f1ade la cantidad de stakeUnits a refundVotes y a amountVotedRefund y se comprueba si hay votos suficientes para realizar el refund (+50%). Si se supera, SE ACTIVA refundDAO y se congelan las transferencias en el TKB . function askForRefund() public { require(icoFinalized, The ICO must end before you ask for a refund. ); require(!refundICO, If refundICO is active, you can't ask for a refund. ); require(voteRestrictionDate = block.timestamp, It's not time yet to ask for a refund. ); uint256 stakeUnits = TKBabi.getStakeUnits(msg.sender); require(stakeUnits != 0, You need 1 or more stake units to vote. ); require(!contributors[msg.sender].votedToRefund, You already voted to get a refund. If you want to undo this, call undoAskForRefund() ); contributors[msg.sender].votedToRefund = true; contributors[msg.sender].amountVotedRefund = stakeUnits; refundVotes = refundVotes.add(stakeUnits); uint256 amountStakeUnits = TKBabi.amountStakeUnits(); if (refundVotes amountStakeUnits/2 amountStakeUnits / 2 500) { // -------------------------- refundDAO = true; TKBabi.freezeTransfer(); } }","title":"askForRefund()"},{"location":"daico/#undoaskforrefund","text":"Se comprueba que la ICO ha terminado, que el refundICO no est\u00e1 activo y que la direcci\u00f3n haya pedido el refund previamente. Luego se saca los votos que realiz\u00f3 la direcci\u00f3n cogiendo amountVotedRefund . Se comprueba que no es 0 y se pone a false votedToRefund y se restan los votos de refundVotes . function undoAskForRefund() public { require(icoFinalized, The ICO must end before you ask for a refund. ); require(!refundICO, If refundICO is active, you can't ask for a refund. ); require(!contributors[msg.sender].votedToRefund, You didn't asked for a refund. ); uint256 stakeUnits = contributors[msg.sender].amountVotedRefund; require(stakeUnits != 0, You need 1 or more stake units to vote. ); contributors[msg.sender].votedToRefund = false; refundVotes = refundVotes.sub(stakeUnits); }","title":"undoAskForRefund()"},{"location":"daico/#withdrawrefunddao","text":"Si se ha activado refundDAO y la direcci\u00f3n no ha pedido un refund previamente, se marca como que va a recibir un refund, se consigue la cantidad de TKB que tiene y si tiene m\u00e1s de 0, se calcula proporcionalmente el wei que hay que mandarle. function withdrawRefundDAO() public { require(refundDAO, Refund must be active. ); require(!contributors[msg.sender].gotRefundDAO, You already got a refund. ); contributors[msg.sender].gotRefundDAO = true; uint256 TKBHold = TKBabi.balanceOf(msg.sender); require(TKBHold != 0, You need to have some TKB to get the refund. ); uint256 _amount = ((address(this).balance).div(tokensSold)).mul(TKBHold); msg.sender.transfer(_amount); }","title":"withdrawRefundDAO()"},{"location":"interface/","text":"Todos los c\u00f3digos utilizados provienen del repositorio de Open Zeppelin . ERC20Basic Interfaz para la creaci\u00f3n de tokens ERC20 con las funcionalidades b\u00e1sicas. contract ERC20Basic { function totalSupply() public view returns(uint256); function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); event Transfer(address indexed from, address indexed to, uint256 value); } ERC20 Interfaz complementaria de ERC20Basic que implementa funcionalidades extra para los tokens ERC20. contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns(uint256); function transferFrom(address from, address to, uint256 value) public returns(bool); function approve(address spender, uint256 value) public returns(bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } SafeMath Librer\u00eda utilizada para la implementaci\u00f3n de elementos de seguridad para las operaci\u00f3nes matem\u00e1ticas. Previene los overflows y lo undeflows. library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b = a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256 c) { c = a + b; assert(c = a); return c; } }","title":"Interfaces y librer\u00edas"},{"location":"interface/#erc20basic","text":"Interfaz para la creaci\u00f3n de tokens ERC20 con las funcionalidades b\u00e1sicas. contract ERC20Basic { function totalSupply() public view returns(uint256); function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); event Transfer(address indexed from, address indexed to, uint256 value); }","title":"ERC20Basic"},{"location":"interface/#erc20","text":"Interfaz complementaria de ERC20Basic que implementa funcionalidades extra para los tokens ERC20. contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns(uint256); function transferFrom(address from, address to, uint256 value) public returns(bool); function approve(address spender, uint256 value) public returns(bool); event Approval( address indexed owner, address indexed spender, uint256 value ); }","title":"ERC20"},{"location":"interface/#safemath","text":"Librer\u00eda utilizada para la implementaci\u00f3n de elementos de seguridad para las operaci\u00f3nes matem\u00e1ticas. Previene los overflows y lo undeflows. library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b = a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256 c) { c = a + b; assert(c = a); return c; } }","title":"SafeMath"},{"location":"ownable/","text":"En este caso, es el c\u00f3digo original de Open Zeppelin con varias funciones enfocadas a crear un super usuario que lo \u00fanico que puede hacer es retirar los permisos a la cuenta de owner . Variables owner address public superUser address public Eventos event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); event SuperUserTransferred( address indexed previousSu, address indexed newSu ); Modificadores onlyOwner() Solo la direcci\u00f3n que tenga el rol de owner puede llamar a la funci\u00f3n. modifier onlyOwner() { require(msg.sender == owner, You are not the owner. ); _; } onlySu() Solo la direcci\u00f3n que tenga el rol de superUser puede llamar a la funci\u00f3n. modifier onlySu() { require(msg.sender == superUser, You are not the super user. ); _; } Funciones constructor() En el momento de la creaci\u00f3n del contrato, se asigna el rol de owner y super usuario a la direcci\u00f3n que haya desplegado el contrato. constructor() public { owner = msg.sender; superUser = msg.sender; } transferSuperUser() El poseedor de los permisos superUsuario transfiere sus permisos a una nueva direcci\u00f3n. function transferSuperUser(address _newSu) public onlySu { require(_newSu != address(0), Adress can't be 0x0000... ); emit SuperUserTransferred(superUser, _newSu); superUser = _newSu; } Argumentos _newSu address Direcci\u00f3n del nuevo super usuario. renounceOwnership() El owner asigna sus permisos a la cuenta 0x000... dejando de ser el owner. function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } transferOwnership() El poseedor de los permisos superUsuario cambia los permisos de owner a la direcci\u00f3n proporcionada. function transferOwnership(address _newOwner) public onlySu { require(_newOwner != address(0), Adress can't be 0x0000... ); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } Argumentos _newOwner address Direcci\u00f3n del nuevo owner.","title":"Ownable"},{"location":"ownable/#variables","text":"owner address public superUser address public","title":"Variables"},{"location":"ownable/#eventos","text":"event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); event SuperUserTransferred( address indexed previousSu, address indexed newSu );","title":"Eventos"},{"location":"ownable/#modificadores","text":"","title":"Modificadores"},{"location":"ownable/#onlyowner","text":"Solo la direcci\u00f3n que tenga el rol de owner puede llamar a la funci\u00f3n. modifier onlyOwner() { require(msg.sender == owner, You are not the owner. ); _; }","title":"onlyOwner()"},{"location":"ownable/#onlysu","text":"Solo la direcci\u00f3n que tenga el rol de superUser puede llamar a la funci\u00f3n. modifier onlySu() { require(msg.sender == superUser, You are not the super user. ); _; }","title":"onlySu()"},{"location":"ownable/#funciones","text":"","title":"Funciones"},{"location":"ownable/#constructor","text":"En el momento de la creaci\u00f3n del contrato, se asigna el rol de owner y super usuario a la direcci\u00f3n que haya desplegado el contrato. constructor() public { owner = msg.sender; superUser = msg.sender; }","title":"constructor()"},{"location":"ownable/#transfersuperuser","text":"El poseedor de los permisos superUsuario transfiere sus permisos a una nueva direcci\u00f3n. function transferSuperUser(address _newSu) public onlySu { require(_newSu != address(0), Adress can't be 0x0000... ); emit SuperUserTransferred(superUser, _newSu); superUser = _newSu; } Argumentos _newSu address Direcci\u00f3n del nuevo super usuario.","title":"transferSuperUser()"},{"location":"ownable/#renounceownership","text":"El owner asigna sus permisos a la cuenta 0x000... dejando de ser el owner. function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); }","title":"renounceOwnership()"},{"location":"ownable/#transferownership","text":"El poseedor de los permisos superUsuario cambia los permisos de owner a la direcci\u00f3n proporcionada. function transferOwnership(address _newOwner) public onlySu { require(_newOwner != address(0), Adress can't be 0x0000... ); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } Argumentos _newOwner address Direcci\u00f3n del nuevo owner.","title":"transferOwnership()"},{"location":"teur/","text":"TEUR - Tikebit Euro La funcionalidad del TEUR es sencilla, ya que es un token ERC20 con todas las funcionalidades de las interfaces ERC20Basic y ERC20 , adem\u00e1s de incluir mint y burn . Variables name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal TKBabi TKB public Mappings El mapping de \"balances\" es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de \"allowed\" guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed; Eventos event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event TKBfee(uint256 amount); Funciones constructor() En el momento de la creaci\u00f3n del contrato, al ser desplegado por el smart contract TKB, teniendo la ABI ya, vinculamos el msg.sender al ABI y tambi\u00e9n le transfiere los permisos a la direcci\u00f3n de _owner . constructor(address _owner) public { TKBabi = TKB(msg.sender); Ownable.transferOwnership(_owner); Ownable.transferSuperUser(_owner); } Argumentos owner address Direcci\u00f3n del nuevo owner y superUser . burn() Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB. Comprueba que _amount no es 0 y que el msg.sender tiene suficiente balance. Despu\u00e9s calcula y asigna el % correspondiente al TKB y despu\u00e9s resta el _amount al msg.sender y resta de totalSupply_ el restante del _amount sin la cantidad enviada al TKB. function burn( uint256 _amount ) public onlyOwner returns (bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender], Insufficient balance. ); address _who = msg.sender; uint256 _amountForTKB = _amount.mul(150).div(10000); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); uint256 _amountWithoutFee = _amount.sub(_amountForTKB); balances[_who] = balances[_who].sub(_amountWithoutFee); totalSupply_ = totalSupply_.sub(_amountWithoutFee); emit Burn(_who, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. mint() Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB y se quitar\u00e1 un Y% correspondiente a la comisi\u00f3n de la tienda que cre\u00f3 el tiket. Comprueba que _amount no es 0, que _to no sea 0x000... y que _fee es mayor que 0 y menor que 500. Despu\u00e9s, calcula y quita la cantidad que se queda el CashNode y calcula la cantidad que se va al TKB y se lo asigna. Una vez ya se han sacado todas las comisiones, se aumenta el totalSupply_ y se le asignan los tokens restantes de _amount . function mint( address _to, uint256 _amount, uint256 _fee ) public onlyOwner returns (bool) { require(_amount 0, Amount must be more than 0 ); require(_to != address(0), You can't send tokens to this address ); require(_fee 0, Fees must be more than 0 ); require(_fee 500, Fees must be lower than 5%-500 units ); uint256 _amountCashNodeFee = _amount.mul(_fee).div(10000); uint256 _amountWithoutFee = _amount.sub(_amountCashNodeFee); totalSupply_ = totalSupply_.add(_amount); uint256 _amountForTKB = _amount.mul(150).div(10000); _amountWithoutFee = _amount.sub(_amountForTKB); balances[_to] = balances[_to].add(_amountWithoutFee); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); emit Mint(_to, _amountWithoutFee); emit TKBfee(_amountForTKB); emit Transfer(address(0), _to, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens a crear. _fee uint256 Cantidad de tokens que se queda el CashNode. _to address Direcci\u00f3n a la que enviar los tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. totalSupply() Devuelve el total de tokens que hay. (Devuelve el totalSupply_ ) function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen. transfer() Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance. Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender], Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir. balanceOf() Devuelve la cantidad de tokens que tiene _owner . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner]; } Argumentos _owner address Direcci\u00f3n de quien devolver el balance. transferFrom() Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from], Insufficient balance. ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. approve() El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. allowance() Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida. increaseApproval() Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. decreaseApproval() Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"TEUR"},{"location":"teur/#teur-tikebit-euro","text":"La funcionalidad del TEUR es sencilla, ya que es un token ERC20 con todas las funcionalidades de las interfaces ERC20Basic y ERC20 , adem\u00e1s de incluir mint y burn .","title":"TEUR - Tikebit Euro"},{"location":"teur/#variables","text":"name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal TKBabi TKB public","title":"Variables"},{"location":"teur/#mappings","text":"El mapping de \"balances\" es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de \"allowed\" guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed;","title":"Mappings"},{"location":"teur/#eventos","text":"event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event TKBfee(uint256 amount);","title":"Eventos"},{"location":"teur/#funciones","text":"","title":"Funciones"},{"location":"teur/#constructor","text":"En el momento de la creaci\u00f3n del contrato, al ser desplegado por el smart contract TKB, teniendo la ABI ya, vinculamos el msg.sender al ABI y tambi\u00e9n le transfiere los permisos a la direcci\u00f3n de _owner . constructor(address _owner) public { TKBabi = TKB(msg.sender); Ownable.transferOwnership(_owner); Ownable.transferSuperUser(_owner); } Argumentos owner address Direcci\u00f3n del nuevo owner y superUser .","title":"constructor()"},{"location":"teur/#burn","text":"Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB. Comprueba que _amount no es 0 y que el msg.sender tiene suficiente balance. Despu\u00e9s calcula y asigna el % correspondiente al TKB y despu\u00e9s resta el _amount al msg.sender y resta de totalSupply_ el restante del _amount sin la cantidad enviada al TKB. function burn( uint256 _amount ) public onlyOwner returns (bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender], Insufficient balance. ); address _who = msg.sender; uint256 _amountForTKB = _amount.mul(150).div(10000); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); uint256 _amountWithoutFee = _amount.sub(_amountForTKB); balances[_who] = balances[_who].sub(_amountWithoutFee); totalSupply_ = totalSupply_.sub(_amountWithoutFee); emit Burn(_who, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"burn()"},{"location":"teur/#mint","text":"Al usar esta funci\u00f3n, se mandar\u00e1 un X% a el contrato TKB y se quitar\u00e1 un Y% correspondiente a la comisi\u00f3n de la tienda que cre\u00f3 el tiket. Comprueba que _amount no es 0, que _to no sea 0x000... y que _fee es mayor que 0 y menor que 500. Despu\u00e9s, calcula y quita la cantidad que se queda el CashNode y calcula la cantidad que se va al TKB y se lo asigna. Una vez ya se han sacado todas las comisiones, se aumenta el totalSupply_ y se le asignan los tokens restantes de _amount . function mint( address _to, uint256 _amount, uint256 _fee ) public onlyOwner returns (bool) { require(_amount 0, Amount must be more than 0 ); require(_to != address(0), You can't send tokens to this address ); require(_fee 0, Fees must be more than 0 ); require(_fee 500, Fees must be lower than 5%-500 units ); uint256 _amountCashNodeFee = _amount.mul(_fee).div(10000); uint256 _amountWithoutFee = _amount.sub(_amountCashNodeFee); totalSupply_ = totalSupply_.add(_amount); uint256 _amountForTKB = _amount.mul(150).div(10000); _amountWithoutFee = _amount.sub(_amountForTKB); balances[_to] = balances[_to].add(_amountWithoutFee); balances[TKBabi] = balances[TKBabi].add(_amountForTKB); emit Mint(_to, _amountWithoutFee); emit TKBfee(_amountForTKB); emit Transfer(address(0), _to, _amountWithoutFee); return true; } Argumentos _amount uint256 Cantidad de tokens a crear. _fee uint256 Cantidad de tokens que se queda el CashNode. _to address Direcci\u00f3n a la que enviar los tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"mint()"},{"location":"teur/#totalsupply","text":"Devuelve el total de tokens que hay. (Devuelve el totalSupply_ ) function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen.","title":"totalSupply()"},{"location":"teur/#transfer","text":"Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance. Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender], Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir.","title":"transfer()"},{"location":"teur/#balanceof","text":"Devuelve la cantidad de tokens que tiene _owner . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner]; } Argumentos _owner address Direcci\u00f3n de quien devolver el balance.","title":"balanceOf()"},{"location":"teur/#transferfrom","text":"Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from], Insufficient balance. ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"transferFrom()"},{"location":"teur/#approve","text":"El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"approve()"},{"location":"teur/#allowance","text":"Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida.","title":"allowance()"},{"location":"teur/#increaseapproval","text":"Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"increaseApproval()"},{"location":"teur/#decreaseapproval","text":"Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"decreaseApproval()"},{"location":"tkb/","text":"TKB - Tikebit Coin El TKB implementa las funcionalidades de ERC20Basic y ERC20 . La finalidad de este token es permitir el reparto de las fee que se generan en el TEUR . Para conseguir esto, se podr\u00e1n generar stakes , que contienen stakeUnits las cuales representan las unidades proporcionales que recibir\u00e1s respecto a la feePool . Tambi\u00e9n se implementa un sistema de fechas donde est\u00e1 todo controlado para que se restrinja cada acci\u00f3n a determinada fecha. Los tokens usados en los stakes se restar\u00e1n del balance de la direcci\u00f3n en funciones como transfer() , transferFrom() y las que requieran saber del balance de tokens de una direcci\u00f3n. Las transferencias estar\u00e1n congeladas hasta que se termine la ICO, la variable que controla esto es stopped . Es posible que una vez terminada la ICO se vuelva a para el contrato, pero solo en el caso de que se pida un refund de la DAICO, permitiendo as\u00ed ir al contrato de la DAICO a retirar ETH a raz\u00f3n de los tokens TKB que tengas. Esta variable no es posible cambiarla de forma manual, se descongelar\u00e1 una vez termine la ICO de forma autom\u00e1tica y al pedir un refund mediante la DAO. El s\u00edstema de fechas siempre estar\u00e1 ligado a dateWeek , al iniciar el contrato, se pondr\u00e1 el unix timestamp de un domingo futuro a las 00:00. De ese modo, el resto de funciones que dependen de horas/fechas, usar\u00e1n la referencia al domingo. Ya que dateWeek ser\u00e1 incrementado semanalmente en 1 weeks . Variables name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal totalFeeCollected uint256 public totalFeeWithdrawn uint256 public dateWeek uint256 public pricePerStakeUnit uint256 public constant amountStakeUnits uint256 public stopped bool public DAICOaddress address public TEURaddress address public VestingAddress address public DAICOabi DAICO public TEURabi TEUR public VestingAbi Vesting public Structs Un Stake est\u00e1 asociado a una direcci\u00f3n, lo cual permite saber la \u00faltima vez que retir\u00f3 fees, cuantos tokens tiene en stake y tiene un array de Units que representa la cantidad de unidades que tiene en stake. struct Stake { uint256 tokensStaked; uint256 dateLastWithdraw; Units[] stakeUnits; } Cuando hablamos de Units , se refiere a la cantidad de pricePerStakeUnit que se han puesto en stake. En este struct, contiene dos valores, la fecha en la que se podr\u00e1 hacer undoStake y la cantidad de unidades que se utilizaron. struct Units { uint256 dateToUnstake; uint256 stakedUnits; } Mappings El mapping de balances es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de allowed guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed; El mapping stake asigna una direcci\u00f3n a un struct Stake . mapping(address = Stake) public stake; Historial de cuanto fee se ha recaudado, asignando la fecha a la cantidad. mapping(uint256 = uint256) internal feesPerWeek; Funciones constructor() En el momento de la creaci\u00f3n del contrato, se desplegar\u00e1 el contrato TEUR , haciendo eso, se guardar\u00e1 la direcci\u00f3n del contrato y se guardar\u00e1 la direcci\u00f3n asociada con la ABI, para poder llamar de forma m\u00e1s sencilla a ese contrato en el futuro. constructor() public { // DAICOaddress = new DAICO(msg.sender, address(this), block.timestamp.add(6 hours)); // DAICOabi = DAICO(DAICOaddress); TEURaddress = new TEUR(msg.sender); TEURabi = TEUR(TEURaddress); // VestingAddress = new Vesting(msg.sender); // VestingAbi = Vesting(VestingAddress); // -- AQU\u00cd HAY QUE DECLARAR MUCHAS VARIABLES Y DECIDIR EL REPARTO INICIAL DE TKB } createStake() La funci\u00f3n est\u00e1 separada en dos para facilitar la auditabilidad del c\u00f3digo, ya que en la primera parte se realizan todas las comprobaciones y en el segundo las acciones. Primero se comprueban las fechas. La direcci\u00f3n tiene que retirar todas las fees hasta la fecha y no se puede hacer stake fuera de las horas indicadas. Despu\u00e9s se calculan las cantidades y se comprueba que la direcci\u00f3n tenga suficiente balance. En la parte de la acci\u00f3n, se incrementan los tokensStaked de la direcci\u00f3n y se a\u00f1ade un struct Units al array de stakeUnits . function createStake( uint256 _unitsToStake ) public { require(stake[msg.sender].dateLastWithdraw == dateWeek || stake[msg.sender].dateLastWithdraw == 0, Withdraw previous fees before staking ); require(block.timestamp = dateWeek.add(2 hours) block.timestamp = dateWeek.add(1 days), It's not time to stake yet ); require(_unitsToStake 0, Units must be more than 1. ); uint256 _amount = _unitsToStake.mul(pricePerStakeUnit); require(balanceOf(msg.sender) = _amount, Insufficient balance ); _createStake(_amount, _unitsToStake, msg.sender); } function _createStake( uint256 _amountToStake, uint256 _unitsToStake, address _user ) internal { stake[_user].tokensStaked = stake[_user].tokensStaked.add(_amountToStake); stake[_user].stakeUnits.push(Units(block.timestamp, _amountToStake)); stake[_user].dateLastWithdraw = dateWeek.add(1 weeks); amountStakeUnits = amountStakeUnits.add(_unitsToStake); } Argumentos _unitsToStake uint256 Cantidad de unidades a incrementar el stake. undoStake() La funci\u00f3n est\u00e1 separada en dos para facilitar la auditabilidad del c\u00f3digo, ya que en la primera parte se realizan todas las comprobaciones y en el segundo las acciones. El array de Units est\u00e1ordenado cronologicamente, donde la posici\u00f3n 0 siempre ser\u00e1n las stakeUnits que antes podr\u00e1s retirar, as\u00ed que la funci\u00f3n siempre apunta a la posici\u00f3n 0. Primero se comprueban las fechas. La direcci\u00f3n tiene que retirar todas las fees hasta la fecha y si las stakeUnits en la posici\u00f3n 0 se pueden retirar. Despues se comprueban las cantidades para saber si se han especificado _unitsToUndoStake mayores que 0 y si es mayor de la cantidad que tiene la direcci\u00f3n en stake. En la parte de la acci\u00f3n, se realiza un bucle donde se sigue el siguiente comportamiento cada iteraci\u00f3n: - Si la posici\u00f3n 0 se puede retirar, comprobando la fecha ( dateToUnstake ) y si _rUnits (unidades restantes) no es 0. - Si se puede, comprueba que las _rUnits , son mayores que el stakedUnits de la posici\u00f3n 0. - Si es mayor, se elimina el elemento del array, se restan las unidades al _rUnits y se vuelve a empezar. - Si es menor, se resta a stakedUnits las _rUnits y se pone a 0. En el caso de que la posici\u00f3n 0 no se pueda retirar o _rUnits sea 0, se termina el bucle y se procede a actualizar los tokensStaked de la direcci\u00f3n y se resta las unidades usadas del total amountStakeUnits . function undoStake( uint256 _unitsToUndoStake ) public { require(stake[msg.sender].dateLastWithdraw == dateWeek, You need to withdraw the fees first ); require(stake[msg.sender].stakeUnits[0].dateToUnstake = block.timestamp, You can't unstake yet ); require(_unitsToUndoStake 0, Units must be more than 0. ); uint256 _amount = _unitsToUndoStake.mul(pricePerStakeUnit); require(stake[msg.sender].tokensStaked = _amount, You are trying to unstake more than you have. ); _undoStake(_unitsToUndoStake, msg.sender); } function _undoStake( uint256 _unitsToUndoStake, address _user ) internal { uint _rUnits = _unitsToUndoStake; for(uint i = 0; i 40; i++){ if(_rUnits 0 stake[_user].stakeUnits[0].dateToUnstake = block.timestamp) { if (stake[_user].stakeUnits[0].stakedUnits = _rUnits) { _rUnits = _rUnits.sub(stake[_user].stakeUnits[0].stakedUnits); removeStakeUnit(0, _user); } else { stake[_user].stakeUnits[0].stakedUnits = stake[_user].stakeUnits[0].stakedUnits.sub(_unitsToUndoStake); _rUnits = 0; } } else { break; } } uint _usedUnits = _unitsToUndoStake.sub(_rUnits); stake[_user].tokensStaked = stake[_user].tokensStaked.sub(_usedUnits.mul(pricePerStakeUnit)); amountStakeUnits = amountStakeUnits.sub(_usedUnits); } Argumentos _unitsToUndoStake uint256 Cantidad de unidades a reducir el stake. removeStakeUnit() Funci\u00f3n interna usada por el undoStake() para eliminar la primera entrada del array. function removeStakeUnit( uint _index, address _user ) internal { for (uint i = _index; i stake[msg.sender].stakeUnits.length-1; i++){ stake[_user].stakeUnits[i] = stake[_user].stakeUnits[i+1]; } stake[_user].stakeUnits.length--; } Argumentos _index uint256 Posici\u00f3n a eliminar del array. _user address Direcci\u00f3n a la cual reducir el array. calculateWeeklyFees() Una vez a la semana, se puede llamar a esta funci\u00f3n para calcular cuanto fee se le ha asignado solo en la \u00faltima semana. Primero comprueba que haya pasado una semana desde la \u00faltima vez que se calcul\u00f3( dateWeek ). Despu\u00e9s se a\u00f1ade 1 semana a dateWeek y se pide la cantidad de tokens TEUR que tiene el TKB . Con eso, se calcula las fees que son de la \u00faltima semana usando el balanceTEUR , la cantidad de fees que se han retirado ( totalFeeWithdrawn ) y la suma de todas las fees hasta la fecha( totalFeeCollected ). Una vez calculado, se divide por la cantidad de stakeUnits que hay en ese momento y se guarda el valor por unidad en el mapping feesPerWeek . Tambi\u00e9n se a\u00f1ade las fee de esta semana al totalFeeCollected . function calculateWeeklyFees() public { require(block.timestamp = dateWeek+1 weeks, You can't do this yet. ); dateWeek = dateWeek.add(1 weeks); uint256 balanceTEUR = TEURabi.balanceOf(this); uint256 _fee = (balanceTEUR.add(totalFeeWithdrawn)).sub(totalFeeCollected); uint256 _feePerUser = _fee.div(amountStakeUnits); totalFeeCollected = totalFeeCollected.add(_fee); feesPerWeek[dateWeek] = _feePerUser; } withdrawFees() Al llamar a esta funci\u00f3n, se retirar\u00e1n las fees asignadas a la direcci\u00f3n que llama de forma autom\u00e1tica. Hay un l\u00edmite de 40 semanas para cobrar, ya que al poner m\u00e1s, puede fallar por el coste elevado de gas de los bucles. Primero se comprueba que la direcci\u00f3n no es 0x000..., que la direcci\u00f3n tenga alg\u00fan stakeUnit y si tiene fees sin retirar. En el bucle, se comprueba si la dateLastWithdraw es menor o igual que dateWeek . Si lo es, se calculan las fees que le corresponden en feesPerWeek[_dateUser] y se le suma 1 semana a _dateUser . Cuando la comprobaci\u00f3n falla, se sale del bucle y se asigna la _dateUser a la dateLastWithdraw , la cual ser\u00e1 dateWeek + 1 semana. Y por \u00faltimo, se le envian desde el TEUR la cantidad total de fees calculada por el bucle. function withdrawFees() public { address _user = msg.sender; require(_user != address(0), Adress can't be 0x0000... ); require(stake[_user].tokensStaked 0, You don't have any stake unit. ); require(stake[_user].dateLastWithdraw = dateWeek, You don't have fees to withdraw. ); uint256 _units = stake[_user].tokensStaked.div(pricePerStakeUnit.mul(decimals)); uint256 _amountFees = 0; uint256 _dateUser = stake[_user].dateLastWithdraw; for (uint256 i = 1; i = 40; i++) { if (_dateUser = dateWeek) { _amountFees = (_amountFees.add(feesPerWeek[_dateUser])).mul(_units); _dateUser = _dateUser.add(1 weeks); } else { break; } } assert(_amountFees 0); stake[_user].dateLastWithdraw = _dateUser; TEURabi.transfer(_user, _amountFees); } getStakeUnits() Devuelve la cantidad de stakeUnits que tiene una direcci\u00f3n. function getStakeUnits( address _user ) public view returns (uint) { return stake[_user].tokensStaked.div(pricePerStakeUnit); } Argumentos _user uint256 Direcci\u00f3n de la cual saber la cantidad de units. freezeTransfer() Solo el contrato de la DAICO puede llamar a esta funci\u00f3n. Al llamar, stopped se pone en true, lo que hace que se congelen las transferencias. function freezeTransfer() public { require(msg.sender == DAICOaddress, Must be called by the DAICO contract. ); stopped = true; } unfreezeTransfer() Solo el contrato de la DAICO puede llamar a esta funci\u00f3n. Al llamar, stopped se pone en false, lo que hace que se descongelen las transferencias. function freezeTransfer() public { require(msg.sender == DAICOaddress, Must be called by the DAICO contract. ); stopped = false; } totalSupply() Devuelve el total de tokens que hay. (Devuelve el totalSupply_ ) function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen. transfer() Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance, restando la cantidad que tiene en stake . Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(!stopped, Transfers are paused. ); require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender].sub(stake[msg.sender].tokensStaked), Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir. balanceOf() Devuelve la cantidad de tokens que tiene _owner , restando la cantidad que tiene en stake . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner].sub(stake[_owner].tokensStaked); } Argumentos _owner address Direcci\u00f3n de quien devolver el balance. transferFrom() Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance, restando la cantidad que tiene en stake y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(!stopped, Transfers are paused. ); require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from].sub(stake[msg.sender].tokensStaked), Insufficient balance ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. approve() El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { require(_value != 0, Value must be more than 0. ); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. allowance() Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida. increaseApproval() Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. decreaseApproval() Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n. burn() Si _amount es mayor que 0 y menor que el balances[msg.sender] , se resta la cantidad _amount del balance de la direcci\u00f3n y del totalSupply_ . function burn( uint256 _amount ) public returns(bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender].sub(stake[msg.sender].tokensStaked), Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_amount); totalSupply_ = totalSupply_.sub(_amount); emit Transfer(msg.sender, address(0), _amount); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"TKB"},{"location":"tkb/#tkb-tikebit-coin","text":"El TKB implementa las funcionalidades de ERC20Basic y ERC20 . La finalidad de este token es permitir el reparto de las fee que se generan en el TEUR . Para conseguir esto, se podr\u00e1n generar stakes , que contienen stakeUnits las cuales representan las unidades proporcionales que recibir\u00e1s respecto a la feePool . Tambi\u00e9n se implementa un sistema de fechas donde est\u00e1 todo controlado para que se restrinja cada acci\u00f3n a determinada fecha. Los tokens usados en los stakes se restar\u00e1n del balance de la direcci\u00f3n en funciones como transfer() , transferFrom() y las que requieran saber del balance de tokens de una direcci\u00f3n. Las transferencias estar\u00e1n congeladas hasta que se termine la ICO, la variable que controla esto es stopped . Es posible que una vez terminada la ICO se vuelva a para el contrato, pero solo en el caso de que se pida un refund de la DAICO, permitiendo as\u00ed ir al contrato de la DAICO a retirar ETH a raz\u00f3n de los tokens TKB que tengas. Esta variable no es posible cambiarla de forma manual, se descongelar\u00e1 una vez termine la ICO de forma autom\u00e1tica y al pedir un refund mediante la DAO. El s\u00edstema de fechas siempre estar\u00e1 ligado a dateWeek , al iniciar el contrato, se pondr\u00e1 el unix timestamp de un domingo futuro a las 00:00. De ese modo, el resto de funciones que dependen de horas/fechas, usar\u00e1n la referencia al domingo. Ya que dateWeek ser\u00e1 incrementado semanalmente en 1 weeks .","title":"TKB - Tikebit Coin"},{"location":"tkb/#variables","text":"name address public constant symbol address public constant decimals uint8 public constant totalSupply_ uint256 internal totalFeeCollected uint256 public totalFeeWithdrawn uint256 public dateWeek uint256 public pricePerStakeUnit uint256 public constant amountStakeUnits uint256 public stopped bool public DAICOaddress address public TEURaddress address public VestingAddress address public DAICOabi DAICO public TEURabi TEUR public VestingAbi Vesting public","title":"Variables"},{"location":"tkb/#structs","text":"Un Stake est\u00e1 asociado a una direcci\u00f3n, lo cual permite saber la \u00faltima vez que retir\u00f3 fees, cuantos tokens tiene en stake y tiene un array de Units que representa la cantidad de unidades que tiene en stake. struct Stake { uint256 tokensStaked; uint256 dateLastWithdraw; Units[] stakeUnits; } Cuando hablamos de Units , se refiere a la cantidad de pricePerStakeUnit que se han puesto en stake. En este struct, contiene dos valores, la fecha en la que se podr\u00e1 hacer undoStake y la cantidad de unidades que se utilizaron. struct Units { uint256 dateToUnstake; uint256 stakedUnits; }","title":"Structs"},{"location":"tkb/#mappings","text":"El mapping de balances es el que controla la cantidad de tokens que tiene cada direcci\u00f3n. mapping(address = uint256) balances; El mapping de allowed guarda la cantidad de tokens que cada direcci\u00f3n ha concedido a otra direcci\u00f3n. mapping(address = mapping(address = uint256)) internal allowed; El mapping stake asigna una direcci\u00f3n a un struct Stake . mapping(address = Stake) public stake; Historial de cuanto fee se ha recaudado, asignando la fecha a la cantidad. mapping(uint256 = uint256) internal feesPerWeek;","title":"Mappings"},{"location":"tkb/#funciones","text":"","title":"Funciones"},{"location":"tkb/#constructor","text":"En el momento de la creaci\u00f3n del contrato, se desplegar\u00e1 el contrato TEUR , haciendo eso, se guardar\u00e1 la direcci\u00f3n del contrato y se guardar\u00e1 la direcci\u00f3n asociada con la ABI, para poder llamar de forma m\u00e1s sencilla a ese contrato en el futuro. constructor() public { // DAICOaddress = new DAICO(msg.sender, address(this), block.timestamp.add(6 hours)); // DAICOabi = DAICO(DAICOaddress); TEURaddress = new TEUR(msg.sender); TEURabi = TEUR(TEURaddress); // VestingAddress = new Vesting(msg.sender); // VestingAbi = Vesting(VestingAddress); // -- AQU\u00cd HAY QUE DECLARAR MUCHAS VARIABLES Y DECIDIR EL REPARTO INICIAL DE TKB }","title":"constructor()"},{"location":"tkb/#createstake","text":"La funci\u00f3n est\u00e1 separada en dos para facilitar la auditabilidad del c\u00f3digo, ya que en la primera parte se realizan todas las comprobaciones y en el segundo las acciones. Primero se comprueban las fechas. La direcci\u00f3n tiene que retirar todas las fees hasta la fecha y no se puede hacer stake fuera de las horas indicadas. Despu\u00e9s se calculan las cantidades y se comprueba que la direcci\u00f3n tenga suficiente balance. En la parte de la acci\u00f3n, se incrementan los tokensStaked de la direcci\u00f3n y se a\u00f1ade un struct Units al array de stakeUnits . function createStake( uint256 _unitsToStake ) public { require(stake[msg.sender].dateLastWithdraw == dateWeek || stake[msg.sender].dateLastWithdraw == 0, Withdraw previous fees before staking ); require(block.timestamp = dateWeek.add(2 hours) block.timestamp = dateWeek.add(1 days), It's not time to stake yet ); require(_unitsToStake 0, Units must be more than 1. ); uint256 _amount = _unitsToStake.mul(pricePerStakeUnit); require(balanceOf(msg.sender) = _amount, Insufficient balance ); _createStake(_amount, _unitsToStake, msg.sender); } function _createStake( uint256 _amountToStake, uint256 _unitsToStake, address _user ) internal { stake[_user].tokensStaked = stake[_user].tokensStaked.add(_amountToStake); stake[_user].stakeUnits.push(Units(block.timestamp, _amountToStake)); stake[_user].dateLastWithdraw = dateWeek.add(1 weeks); amountStakeUnits = amountStakeUnits.add(_unitsToStake); } Argumentos _unitsToStake uint256 Cantidad de unidades a incrementar el stake.","title":"createStake()"},{"location":"tkb/#undostake","text":"La funci\u00f3n est\u00e1 separada en dos para facilitar la auditabilidad del c\u00f3digo, ya que en la primera parte se realizan todas las comprobaciones y en el segundo las acciones. El array de Units est\u00e1ordenado cronologicamente, donde la posici\u00f3n 0 siempre ser\u00e1n las stakeUnits que antes podr\u00e1s retirar, as\u00ed que la funci\u00f3n siempre apunta a la posici\u00f3n 0. Primero se comprueban las fechas. La direcci\u00f3n tiene que retirar todas las fees hasta la fecha y si las stakeUnits en la posici\u00f3n 0 se pueden retirar. Despues se comprueban las cantidades para saber si se han especificado _unitsToUndoStake mayores que 0 y si es mayor de la cantidad que tiene la direcci\u00f3n en stake. En la parte de la acci\u00f3n, se realiza un bucle donde se sigue el siguiente comportamiento cada iteraci\u00f3n: - Si la posici\u00f3n 0 se puede retirar, comprobando la fecha ( dateToUnstake ) y si _rUnits (unidades restantes) no es 0. - Si se puede, comprueba que las _rUnits , son mayores que el stakedUnits de la posici\u00f3n 0. - Si es mayor, se elimina el elemento del array, se restan las unidades al _rUnits y se vuelve a empezar. - Si es menor, se resta a stakedUnits las _rUnits y se pone a 0. En el caso de que la posici\u00f3n 0 no se pueda retirar o _rUnits sea 0, se termina el bucle y se procede a actualizar los tokensStaked de la direcci\u00f3n y se resta las unidades usadas del total amountStakeUnits . function undoStake( uint256 _unitsToUndoStake ) public { require(stake[msg.sender].dateLastWithdraw == dateWeek, You need to withdraw the fees first ); require(stake[msg.sender].stakeUnits[0].dateToUnstake = block.timestamp, You can't unstake yet ); require(_unitsToUndoStake 0, Units must be more than 0. ); uint256 _amount = _unitsToUndoStake.mul(pricePerStakeUnit); require(stake[msg.sender].tokensStaked = _amount, You are trying to unstake more than you have. ); _undoStake(_unitsToUndoStake, msg.sender); } function _undoStake( uint256 _unitsToUndoStake, address _user ) internal { uint _rUnits = _unitsToUndoStake; for(uint i = 0; i 40; i++){ if(_rUnits 0 stake[_user].stakeUnits[0].dateToUnstake = block.timestamp) { if (stake[_user].stakeUnits[0].stakedUnits = _rUnits) { _rUnits = _rUnits.sub(stake[_user].stakeUnits[0].stakedUnits); removeStakeUnit(0, _user); } else { stake[_user].stakeUnits[0].stakedUnits = stake[_user].stakeUnits[0].stakedUnits.sub(_unitsToUndoStake); _rUnits = 0; } } else { break; } } uint _usedUnits = _unitsToUndoStake.sub(_rUnits); stake[_user].tokensStaked = stake[_user].tokensStaked.sub(_usedUnits.mul(pricePerStakeUnit)); amountStakeUnits = amountStakeUnits.sub(_usedUnits); } Argumentos _unitsToUndoStake uint256 Cantidad de unidades a reducir el stake.","title":"undoStake()"},{"location":"tkb/#removestakeunit","text":"Funci\u00f3n interna usada por el undoStake() para eliminar la primera entrada del array. function removeStakeUnit( uint _index, address _user ) internal { for (uint i = _index; i stake[msg.sender].stakeUnits.length-1; i++){ stake[_user].stakeUnits[i] = stake[_user].stakeUnits[i+1]; } stake[_user].stakeUnits.length--; } Argumentos _index uint256 Posici\u00f3n a eliminar del array. _user address Direcci\u00f3n a la cual reducir el array.","title":"removeStakeUnit()"},{"location":"tkb/#calculateweeklyfees","text":"Una vez a la semana, se puede llamar a esta funci\u00f3n para calcular cuanto fee se le ha asignado solo en la \u00faltima semana. Primero comprueba que haya pasado una semana desde la \u00faltima vez que se calcul\u00f3( dateWeek ). Despu\u00e9s se a\u00f1ade 1 semana a dateWeek y se pide la cantidad de tokens TEUR que tiene el TKB . Con eso, se calcula las fees que son de la \u00faltima semana usando el balanceTEUR , la cantidad de fees que se han retirado ( totalFeeWithdrawn ) y la suma de todas las fees hasta la fecha( totalFeeCollected ). Una vez calculado, se divide por la cantidad de stakeUnits que hay en ese momento y se guarda el valor por unidad en el mapping feesPerWeek . Tambi\u00e9n se a\u00f1ade las fee de esta semana al totalFeeCollected . function calculateWeeklyFees() public { require(block.timestamp = dateWeek+1 weeks, You can't do this yet. ); dateWeek = dateWeek.add(1 weeks); uint256 balanceTEUR = TEURabi.balanceOf(this); uint256 _fee = (balanceTEUR.add(totalFeeWithdrawn)).sub(totalFeeCollected); uint256 _feePerUser = _fee.div(amountStakeUnits); totalFeeCollected = totalFeeCollected.add(_fee); feesPerWeek[dateWeek] = _feePerUser; }","title":"calculateWeeklyFees()"},{"location":"tkb/#withdrawfees","text":"Al llamar a esta funci\u00f3n, se retirar\u00e1n las fees asignadas a la direcci\u00f3n que llama de forma autom\u00e1tica. Hay un l\u00edmite de 40 semanas para cobrar, ya que al poner m\u00e1s, puede fallar por el coste elevado de gas de los bucles. Primero se comprueba que la direcci\u00f3n no es 0x000..., que la direcci\u00f3n tenga alg\u00fan stakeUnit y si tiene fees sin retirar. En el bucle, se comprueba si la dateLastWithdraw es menor o igual que dateWeek . Si lo es, se calculan las fees que le corresponden en feesPerWeek[_dateUser] y se le suma 1 semana a _dateUser . Cuando la comprobaci\u00f3n falla, se sale del bucle y se asigna la _dateUser a la dateLastWithdraw , la cual ser\u00e1 dateWeek + 1 semana. Y por \u00faltimo, se le envian desde el TEUR la cantidad total de fees calculada por el bucle. function withdrawFees() public { address _user = msg.sender; require(_user != address(0), Adress can't be 0x0000... ); require(stake[_user].tokensStaked 0, You don't have any stake unit. ); require(stake[_user].dateLastWithdraw = dateWeek, You don't have fees to withdraw. ); uint256 _units = stake[_user].tokensStaked.div(pricePerStakeUnit.mul(decimals)); uint256 _amountFees = 0; uint256 _dateUser = stake[_user].dateLastWithdraw; for (uint256 i = 1; i = 40; i++) { if (_dateUser = dateWeek) { _amountFees = (_amountFees.add(feesPerWeek[_dateUser])).mul(_units); _dateUser = _dateUser.add(1 weeks); } else { break; } } assert(_amountFees 0); stake[_user].dateLastWithdraw = _dateUser; TEURabi.transfer(_user, _amountFees); }","title":"withdrawFees()"},{"location":"tkb/#getstakeunits","text":"Devuelve la cantidad de stakeUnits que tiene una direcci\u00f3n. function getStakeUnits( address _user ) public view returns (uint) { return stake[_user].tokensStaked.div(pricePerStakeUnit); } Argumentos _user uint256 Direcci\u00f3n de la cual saber la cantidad de units.","title":"getStakeUnits()"},{"location":"tkb/#freezetransfer","text":"Solo el contrato de la DAICO puede llamar a esta funci\u00f3n. Al llamar, stopped se pone en true, lo que hace que se congelen las transferencias. function freezeTransfer() public { require(msg.sender == DAICOaddress, Must be called by the DAICO contract. ); stopped = true; }","title":"freezeTransfer()"},{"location":"tkb/#unfreezetransfer","text":"Solo el contrato de la DAICO puede llamar a esta funci\u00f3n. Al llamar, stopped se pone en false, lo que hace que se descongelen las transferencias. function freezeTransfer() public { require(msg.sender == DAICOaddress, Must be called by the DAICO contract. ); stopped = false; }","title":"unfreezeTransfer()"},{"location":"tkb/#totalsupply","text":"Devuelve el total de tokens que hay. (Devuelve el totalSupply_ ) function totalSupply() public view returns(uint256) { return totalSupply_; } Devuelve uint256 Cantidad de tokens que existen.","title":"totalSupply()"},{"location":"tkb/#transfer","text":"Comprueba que _to no es la direcci\u00f3n 0x000... y que el msg.sender tiene suficiente balance, restando la cantidad que tiene en stake . Despu\u00e9s realiza la transferencia y emite el evento. function transfer( address _to, uint256 _value ) public returns(bool) { require(!stopped, Transfers are paused. ); require(_to != address(0), Address can't be 0x0000... ); require(_value = balances[msg.sender].sub(stake[msg.sender].tokensStaked), Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } Argumentos _to address Direcci\u00f3n del destinatario. _value uint256 Cantidad a transferir.","title":"transfer()"},{"location":"tkb/#balanceof","text":"Devuelve la cantidad de tokens que tiene _owner , restando la cantidad que tiene en stake . function balanceOf(address _owner) public view returns(uint256) { return balances[_owner].sub(stake[_owner].tokensStaked); } Argumentos _owner address Direcci\u00f3n de quien devolver el balance.","title":"balanceOf()"},{"location":"tkb/#transferfrom","text":"Comprueba que _to no es la direcci\u00f3n 0x000..., que _from tenga suficiente balance, restando la cantidad que tiene en stake y que _from le haya concedido suficiente balance a msg.sender . Despu\u00e9s reduce el balance de _from , incrementa el balance de _to y reduce el allowance de _from a msg.sender . function transferFrom( address _from, address _to, uint256 _value ) public returns(bool) { require(!stopped, Transfers are paused. ); require(_to != address(0), Adress can't be 0x0000... ); require(_value = balances[_from].sub(stake[msg.sender].tokensStaked), Insufficient balance ); require(_value = allowed[_from][msg.sender], Insufficient balance allowed. ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } Argumentos _from address Direcci\u00f3n de la que sacar los tokens. _to address Direcci\u00f3n a quien enviar los tokens. _value uint256 Cantidad de tokens a sacar. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"transferFrom()"},{"location":"tkb/#approve","text":"El msg.sender concede a _spender la cantidad de tokens _value . function approve( address _spender, uint256 _value ) public returns(bool) { require(_value != 0, Value must be more than 0. ); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } Argumentos _spender address Direcci\u00f3n a quien ceder los tokens. _value uint256 Cantidad de tokens a ceder. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"approve()"},{"location":"tkb/#allowance","text":"Devuelve cuantos tokens le ha cedido _owner a _spender . function allowance( address _owner, address _spender ) public view returns(uint256) { return allowed[_owner][_spender]; } Argumentos _owner address Direcci\u00f3n que cede los tokens _spender address Direcci\u00f3n a quien han cedido tokens. Devuelve uint256 Cantidad cedida.","title":"allowance()"},{"location":"tkb/#increaseapproval","text":"Incrementa la cantidad cedida de msg.sender a _spender . La cantidad se indica en _addedValue . function increaseApproval( address _spender, uint256 _addedValue ) public returns(bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _addedValue uint256 Cantidad a aumentar la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"increaseApproval()"},{"location":"tkb/#decreaseapproval","text":"Reduce la cantidad cedida de msg.sender a _spender . La cantidad se indica en _subtractedValue . function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns(bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } Argumentos _spender address Direcci\u00f3n a quien han cedido tokens. _subtractedValue uint256 Cantidad a reducir la cesi\u00f3n. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"decreaseApproval()"},{"location":"tkb/#burn","text":"Si _amount es mayor que 0 y menor que el balances[msg.sender] , se resta la cantidad _amount del balance de la direcci\u00f3n y del totalSupply_ . function burn( uint256 _amount ) public returns(bool) { require(_amount 0, The value must be more than 0 ); require(_amount = balances[msg.sender].sub(stake[msg.sender].tokensStaked), Insufficient balance ); balances[msg.sender] = balances[msg.sender].sub(_amount); totalSupply_ = totalSupply_.sub(_amount); emit Transfer(msg.sender, address(0), _amount); return true; } Argumentos _amount uint256 Cantidad de tokens. Devuelve bool Comprobaci\u00f3n de que ha acabado la funci\u00f3n.","title":"burn()"},{"location":"vesting/","text":"Vesting En este contrato se asignar\u00e1n a cada direcci\u00f3n las cantidades de tokens TKB y fecha de retirada que se hayan pactado previamente. Este contrato est\u00e1 destinado a guardar y congelar los tokens destinados al equipo, advisors, private sale, etc. La introducci\u00f3n de direcciones solo puede hacerse desde la direcci\u00f3n de owner , pero solo las direcciones apuntadas podr\u00e1n retirar fondos una vez se haya pasado el tiempo necesario Variables amountWithdrawn uint256 public constant TKBabi TKB public categories Category[] public Structs Cada Category representa los diferentes tipos de grupos que recibir\u00e1n tokens. struct Category { string name; uint256 amount; uint256 filledAmount; uint256 withdrawDate; mapping(address = uint) participantAmount; } Mappings Guarda el index de la Category a la que est\u00e1 asignado. mapping(address = uint) userCategory; Guarda las direcciones que ya han retirado su tokens. mapping(address = bool) alreadyWithdrawn; Funciones constructor() En el momento de la creaci\u00f3n del contrato, se generar\u00e1n las Category que se especifiquen. constructor(address _owner) public { categories.push(Category( Private sale , 50000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Pre sale , 100000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Team , 200000000*1000000000000000000, 0, block.timestamp.add(48 weeks))); categories.push(Category( Advisors , 30000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Partnerships , 30000000*1000000000000000000, 0, block.timestamp.add(12 weeks))); } addAddress() A\u00f1ade una direcci\u00f3n a la Category que se indique en _index y se le asigna la cantidad especificada en _amount . Primero se comprueba que la direcci\u00f3n no sea 0x000..., que el _index especificado es valido y si el _amount a\u00f1adido al total de la categor\u00eda, no pasa el limite de dicha Category . Despues se incrementa el filledAmount de la Category indicada y se le asigna el _amount en el mapping participantAmount . function addAddress( address _who, uint256 _amount, uint256 _index ) public onlyOwner { require(_who != address(0), Address can't be 0x0000... ); require(_index = 0 _index categories.length.sub(1), Index has to be valid ); require(_amount != 0, Amount must be more than 0 ); require(_amount.add(categories[_index].filledAmount) categories[_index].amount, Amount exceeds the limit. ); categories[_index].filledAmount = categories[_index].filledAmount.add(_amount); categories[_index].participantAmount[_who] = categories[_index].participantAmount[_who].add(_amount); userCategory[_who] = _index; } Argumentos _who string Direcci\u00f3n que se va a a\u00f1adir. _amount uint256 Cantidad a a\u00f1adir. _index uint256 \u00cdndice de la categor\u00eda. withdraw() Primero se comprueba que la direcci\u00f3n puede sacar ya los fondos, si ya ha retirado los fondos y si tiene alg\u00fan token que poder retirar. Despues, se le asigna que ya ha retirado los tokens, se incrementa amountWithdrawn y finalmente se le transfieren los tokens TKB . function withdraw() public { address _who = msg.sender; require(categories[userCategory[_who]].withdrawDate = block.timestamp, You can't withdraw yet. ); require(!alreadyWithdrawn[_who], Already withdrawn. ); uint256 _amount = categories[userCategory[_who]].participantAmount[_who]; require(_amount != 0, You don't have any amount to withdraw ); alreadyWithdrawn[_who] = true; amountWithdrawn = amountWithdrawn.add(_amount); TKBabi.transfer(_who, _amount); } Argumentos _who string Direcci\u00f3n que se va a retirar los fondos. getUserBalance() Devuelve la cantidad de tokens que tiene asignado _who . function getUserBalance( address _who ) public view returns (uint) { return categories[userCategory[_who]].participantAmount[_who]; } Argumentos _who string Direcci\u00f3n de la cual devolver el balance. Devuelve uint256 Balance del usuario.","title":"Vesting"},{"location":"vesting/#vesting","text":"En este contrato se asignar\u00e1n a cada direcci\u00f3n las cantidades de tokens TKB y fecha de retirada que se hayan pactado previamente. Este contrato est\u00e1 destinado a guardar y congelar los tokens destinados al equipo, advisors, private sale, etc. La introducci\u00f3n de direcciones solo puede hacerse desde la direcci\u00f3n de owner , pero solo las direcciones apuntadas podr\u00e1n retirar fondos una vez se haya pasado el tiempo necesario","title":"Vesting"},{"location":"vesting/#variables","text":"amountWithdrawn uint256 public constant TKBabi TKB public categories Category[] public","title":"Variables"},{"location":"vesting/#structs","text":"Cada Category representa los diferentes tipos de grupos que recibir\u00e1n tokens. struct Category { string name; uint256 amount; uint256 filledAmount; uint256 withdrawDate; mapping(address = uint) participantAmount; }","title":"Structs"},{"location":"vesting/#mappings","text":"Guarda el index de la Category a la que est\u00e1 asignado. mapping(address = uint) userCategory; Guarda las direcciones que ya han retirado su tokens. mapping(address = bool) alreadyWithdrawn;","title":"Mappings"},{"location":"vesting/#funciones","text":"","title":"Funciones"},{"location":"vesting/#constructor","text":"En el momento de la creaci\u00f3n del contrato, se generar\u00e1n las Category que se especifiquen. constructor(address _owner) public { categories.push(Category( Private sale , 50000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Pre sale , 100000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Team , 200000000*1000000000000000000, 0, block.timestamp.add(48 weeks))); categories.push(Category( Advisors , 30000000*1000000000000000000, 0, block.timestamp.add(24 weeks))); categories.push(Category( Partnerships , 30000000*1000000000000000000, 0, block.timestamp.add(12 weeks))); }","title":"constructor()"},{"location":"vesting/#addaddress","text":"A\u00f1ade una direcci\u00f3n a la Category que se indique en _index y se le asigna la cantidad especificada en _amount . Primero se comprueba que la direcci\u00f3n no sea 0x000..., que el _index especificado es valido y si el _amount a\u00f1adido al total de la categor\u00eda, no pasa el limite de dicha Category . Despues se incrementa el filledAmount de la Category indicada y se le asigna el _amount en el mapping participantAmount . function addAddress( address _who, uint256 _amount, uint256 _index ) public onlyOwner { require(_who != address(0), Address can't be 0x0000... ); require(_index = 0 _index categories.length.sub(1), Index has to be valid ); require(_amount != 0, Amount must be more than 0 ); require(_amount.add(categories[_index].filledAmount) categories[_index].amount, Amount exceeds the limit. ); categories[_index].filledAmount = categories[_index].filledAmount.add(_amount); categories[_index].participantAmount[_who] = categories[_index].participantAmount[_who].add(_amount); userCategory[_who] = _index; } Argumentos _who string Direcci\u00f3n que se va a a\u00f1adir. _amount uint256 Cantidad a a\u00f1adir. _index uint256 \u00cdndice de la categor\u00eda.","title":"addAddress()"},{"location":"vesting/#withdraw","text":"Primero se comprueba que la direcci\u00f3n puede sacar ya los fondos, si ya ha retirado los fondos y si tiene alg\u00fan token que poder retirar. Despues, se le asigna que ya ha retirado los tokens, se incrementa amountWithdrawn y finalmente se le transfieren los tokens TKB . function withdraw() public { address _who = msg.sender; require(categories[userCategory[_who]].withdrawDate = block.timestamp, You can't withdraw yet. ); require(!alreadyWithdrawn[_who], Already withdrawn. ); uint256 _amount = categories[userCategory[_who]].participantAmount[_who]; require(_amount != 0, You don't have any amount to withdraw ); alreadyWithdrawn[_who] = true; amountWithdrawn = amountWithdrawn.add(_amount); TKBabi.transfer(_who, _amount); } Argumentos _who string Direcci\u00f3n que se va a retirar los fondos.","title":"withdraw()"},{"location":"vesting/#getuserbalance","text":"Devuelve la cantidad de tokens que tiene asignado _who . function getUserBalance( address _who ) public view returns (uint) { return categories[userCategory[_who]].participantAmount[_who]; } Argumentos _who string Direcci\u00f3n de la cual devolver el balance. Devuelve uint256 Balance del usuario.","title":"getUserBalance()"}]}